<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML LANG="en">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 7.0/HTML Export Filter">

<LINK REL="STYLESHEET" HREF="unx_unstr_styles.css" CHARSET="ISO-8859-1" TYPE="text/css">
<META name="DC.TITLE" content="Virtual Machine Specification, Java Card Platform, v2.2.2">
<TITLE>C H A P T E R    7 - Java Card Virtual Machine  Instruction Set 
</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<div class="navbar" align="center">
<table dir="LTR" summary="Navigation bar, includes the book title and navigation buttons" width=100% cellpadding="0" cellspacing="0" border="0"><colgroup span="2" width="100%"><col id="1" span="1" width="50%"><col id="2" span="1" width="50%">
<tr bgcolor="#cccccc">
<td class="navbartitle" align=left rowspan="1" colspan="1" abbr="ChapTitle">&nbsp;&nbsp;Virtual Machine Specification, Java Card Platform, v2.2.2
</td>
<td valign="top" align="right" rowspan="1" colspan="1" abbr="NavButtons"><a href="index.html"><img src="shared/toc01.gif" title="Table Of Contents" alt="Table Of Contents" width="30" height="26" border="0"></a><a href="JCVM06cap.html"><img src="shared/prev01.gif" title="Previous Chapter" alt="Previous Chapter" width="30" height="26" border="0"></a><a href="JCVM08instrTables.html"><img src="shared/next01.gif" title="Next Chapter" alt="Next Chapter" width="30" height="26" border="0"></a><a href="ix.html"><img src="shared/index01.gif" title="Book Index" alt="Book Index" width="30" height="26" border="0"></a>
</td>
</tr>
</table>
<br>
<br>
</div>
</DIV>
<TABLE DIR="LTR" SUMMARY="Chapter Number" ABBR="ChapNum" WIDTH="100%" BORDER="0">
<COLGROUP SPAN="1" WIDTH="100%"><COL ID="1" SPAN="1">
<TR>
<TD ALIGN="right" CLASS="ChapNumber"><SPAN CLASS="ChapNumPrefix"><A NAME="pgfId-6948"></A>C H A P T E R    </SPAN>&nbsp;<SPAN CLASS="ChapNumNum">7</SPAN><A NAME="83338"></A>
</TD>
</TR>
</TABLE>
<TABLE DIR="LTR" SUMMARY="Chapter Title" ABBR="ChapTitle" WIDTH="100%" BORDER="0">
<COLGROUP SPAN="1" WIDTH="100%"><COL ID="1" SPAN="1" WIDTH="100%">
<TR>
<TD ALIGN="right" CLASS="ChapTitle">
<HR SIZE=7 NOSHADE><A NAME="pgfId-6949"></A><A NAME="11178"></A>Java Card Virtual Machine <A NAME="marker-54552"></A>Instruction Set
</TD>
</TR>
</TABLE>
<P CLASS="Paragraph"><A NAME="pgfId-6950"></A>A Java Card virtual machine instruction consists of an opcode specifying the operation to be performed, followed by zero or more operands embodying values to be operated upon. This chapter gives details about the format of each Java Card virtual machine instruction and the operation it performs.
</P><H2 CLASS="Head1"><A NAME="pgfId-6951"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>7.1	Assumptions: The Meaning of &quot;<A NAME="marker-54553"></A>Must&quot;</H2>
<P CLASS="Paragraph"><A NAME="pgfId-26294"></A>The description of each instruction is always given in the context of Java Card virtual machine code that satisfies the static and structural constraints of <A HREF="JCVM06cap.html#74217" CLASS="XRef">Chapter 6</A>, &quot;The CAP File Format&quot;.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26295"></A>In the description of individual Java Card virtual machine instructions, we frequently state that some situation &quot;must&quot; or &quot;must not&quot; be the case: &quot;The value2 must be of type int.&quot; The constraints of <A HREF="JCVM06cap.html#74217" CLASS="XRef">Chapter 6</A> &quot;The CAP File Format&quot; guarantee that all such expectations will in fact be met. If some constraint (a &quot;must&quot; or &quot;must not&quot;) in an instruction description is not satisfied at run time, the behavior of the Java Card virtual machine is undefined.
</P><H2 CLASS="Head1"><A NAME="pgfId-6960"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>7.2	Reserved <A NAME="marker-54554"></A>Opcodes</H2>
<P CLASS="Paragraph"><A NAME="pgfId-6961"></A>In addition to the opcodes of the instructions specified later this chapter, which are used in Java Card CAP files (see <A HREF="JCVM06cap.html#74217" CLASS="XRef">Chapter 6</A>, &quot;The CAP File Format&quot;), two opcodes are reserved for internal use by a Java Card virtual machine implementation. If Sun Microsystems, Inc. extends the instruction set of the Java Card virtual machine in the future, these reserved opcodes are guaranteed not to be used.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-6962"></A>The two reserved opcodes, numbers 254 (0xfe) and 255 (0xff), have the mnemonics impdep1 and impdep2, respectively. These instructions are intended to provide &quot;back doors&quot; or traps to implementation-specific functionality implemented in software and hardware, respectively.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-6963"></A>Although these opcodes have been reserved, they may only be used inside a Java Card virtual machine implementation. They cannot appear in valid CAP files.
</P><H2 CLASS="Head1"><A NAME="pgfId-6964"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>7.3	Virtual Machine <A NAME="marker-54555"></A>Errors</H2>
<P CLASS="Paragraph"><A NAME="pgfId-1006533"></A>A Java Card virtual machine may encounter internal errors or resource limitations that prevent it from executing correctly written Java programs. While The Java Virtual Machine Specification allows reporting and handling of virtual machine errors, it also states that they cannot ordinarily be handled by application code. This Virtual Machine Specification for the Java Card Platform, v2.2.2 is more restrictive in that it does not allow for any reporting or handling of unrecoverable virtual machine errors at the application code level. A virtual machine error is considered unrecoverable if further execution could compromise the security or correct operation of the virtual machine or underlying system software. When an unrecoverable error occurs, the virtual machine will halt bytecode execution. Responses beyond halting the virtual machine are implementation-specific policies and are not mandated in this specification.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-27036"></A>In the case where the virtual machine encounters a recoverable error, such as insufficient memory to allocate a new object, it will throw a SystemException with an error code describing the error condition. The Virtual Machine Specification for the Java Card Platform, v2.2.2 cannot predict where resource limitations or internal errors may be encountered and does not mandate precisely when they can be reported. Thus, a SystemException may be thrown at any time during the operation of the Java Card virtual machine.
</P><H2 CLASS="Head1"><A NAME="pgfId-6969"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>7.4	Security <A NAME="marker-54556"></A>Exceptions</H2>
<P CLASS="Paragraph"><A NAME="pgfId-6970"></A>Instructions of the Java Card virtual machine throw an instance of the class SecurityException when a security violation has been detected. The Java Card virtual machine does not mandate the complete set of security violations that can or will result in an exception being thrown. However, there is a minimum set that must be supported.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1003636"></A>In the general case, any instruction that de-references an object reference must throw a SecurityException if the context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) in which the instruction is executing is different than the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the referenced object. The list of instructions includes the instance field get and put instructions, the array load and store instructions, as well as the arraylength, invokeinterface, invokespecial, invokevirtual, checkcast, instanceof and athrow instructions.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26037"></A>There are several exceptions to this general rule that allow cross-context use of objects or arrays. These exceptions are detailed in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification for the Java Card Platform, Version 2.2.2</EM>. An important detail to note is that any cross-context method invocation will result in a context switch (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>).
</P>
<P CLASS="Paragraph"><A NAME="pgfId-6972"></A>The Java Card virtual machine may also throw a SecurityException if an instruction violates any of the static constraints of <A HREF="JCVM06cap.html#74217" CLASS="XRef">Chapter 6</A>, &quot;The CAP File Format&quot;. The <EM CLASS="Emphasis">Virtual Machine Specification for the Java Card Platform, Version 2.2.2</EM> does not mandate which instructions must implement these additional security checks, or to what level. Therefore, a <KBD CLASS="Filename-Command">SecurityException</KBD> may be thrown at any time during the operation of the Java Card virtual machine.
</P><H2 CLASS="Head1"><A NAME="pgfId-6979"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>7.5	The Java Card Virtual Machine Instruction Set</H2>
<P CLASS="Paragraph"><A NAME="pgfId-6980"></A>Java virtual machine instructions are represented in this chapter by entries of the form shown in <A HREF="JCVM07instr.html#38563" CLASS="XRef">TABLE 7-1</A>, an example instruction page, in alphabetical order.
</P>
<TABLE CLASS="TitledNoRules" BORDER=0 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0><CAPTION CLASS="TableCaption"><A NAME="pgfId-1017850"> </A> TABLE 7-1 	 <A NAME="38563"> </A> Example Instruction Page </CAPTION>
<TR>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1017770"></A>mnemonic
</P>
<P CLASS="TableText"><A NAME="pgfId-1017800"></A>Short description of the instruction.
</P>
<P CLASS="TableText"><A NAME="pgfId-1017807"></A>Format
</P>
<P CLASS="TableText"><A NAME="pgfId-1017808"></A>mnemonic
</P>
<P CLASS="TableText"><A NAME="pgfId-1017809"></A>operand1
</P>
<P CLASS="TableText"><A NAME="pgfId-1017810"></A>operand2
</P>
<P CLASS="TableText"><A NAME="pgfId-1017812"></A>...
</P>
<P CLASS="TableText"><A NAME="pgfId-1017813"></A>Forms
</P>
<P CLASS="TableText"><A NAME="pgfId-1017875"></A>mnemonic = opcode
</P>
<P CLASS="TableText"><A NAME="pgfId-1017832"></A>Stack
</P>
<P CLASS="TableText"><A NAME="pgfId-1017833"></A>..., value1, value2 -&gt;
</P>
<P CLASS="TableText"><A NAME="pgfId-1017834"></A>.../ value3
</P>
<P CLASS="TableText"><A NAME="pgfId-1017840"></A>Description
</P>
<P CLASS="TableText"><A NAME="pgfId-1017841"></A>A longer description detailing constraints on operand stack contents or constant pool entries, the operation performed, the type of the results, and so on.
</P>
<P CLASS="TableText"><A NAME="pgfId-1017842"></A>Runtime Exception
</P>
<P CLASS="TableText"><A NAME="pgfId-1017843"></A>If any runtime exceptions can be thrown by the execution of an instruction, that instruction must not throw any runtime exceptions except for instances of System Exception.
</P>
<P CLASS="TableText"><A NAME="pgfId-1017844"></A>Notes 
</P>
<P CLASS="TableText"><A NAME="pgfId-1017848"></A>Commands not strictly part of the specification of an instruction are set aside as notes at the end of the description.
</P>
</TD>
</TR>
</TABLE><ENDTABLEOBJECT CLASS="EndTableObject"><A NAME="pgfId-1024223"></A>&nbsp;</ENDTABLEOBJECT>
<P CLASS="Paragraph"><A NAME="pgfId-1006773"></A>Each cell in the instruction format diagram represents a single 8-bit byte. The instruction's <A NAME="marker-1006774"></A>mnemonic is its name. Its opcode is its numeric representation and is given in both decimal and hexadecimal forms. Only the numeric representation is actually present in the Java Card virtual machine code in a CAP file.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7006"></A>Keep in mind that there are &quot;operands&quot; generated at compile time and embedded within Java Card virtual machine instructions, as well as &quot;operands&quot; calculated at run time and supplied on the operand stack. Although they are supplied from several different areas, all these operands represent the same thing: values to be operated upon by the Java Card virtual machine instruction being executed. By implicitly taking many of its operands from its operand stack, rather than representing them explicitly in its compiled code as additional operand bytes, register numbers, etc., the Java Card virtual machine's code stays compact.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7007"></A>Some instructions are presented as members of a family of related instructions sharing a single description, format, and operand stack diagram. As such, a family of instructions includes several opcodes and opcode mnemonics; only the family mnemonic appears in the instruction format diagram, and a separate forms line lists all member mnemonics and opcodes. For example, the forms line for the sconst_&lt;s&gt; family of instructions, giving mnemonic and opcode information for the two instructions in that family (sconst_0 and sconst_1), is
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26189"></A>Forms  sconst_0 = 3 (0x3), 
<BR>            sconst_1 = 4 (0x4)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26191"></A>In the description of the Java Card virtual machine instructions, the effect of an instruction's execution on the operand stack (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>) of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>) is represented textually, with the stack growing from left to right and each word represented separately. Thus,
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7013"></A>Stack..., value1, value2 -&gt;
<BR>         ..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7015"></A>shows an operation that begins by having a one-word value2 on top of the operand stack with a one-word value1 just beneath it. As a result of the execution of the instruction, value1 and value2 are popped from the operand stack and replaced by a one-word result, which has been calculated by the instruction. The remainder of the operand stack, represented by an ellipsis (...), is unaffected by the instruction's execution.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7016"></A>The type int takes two words on the operand stack. In the operand stack representation, each word is represented separately using a dot notation:
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7018"></A>Stack..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>         ..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7020"></A>The Virtual Machine Specification for the Java Card Platform, v2.2.2 does not mandate how the two words are used to represent the 32-bit int value; it only requires that a particular implementation be internally consistent.
</P><H3 CLASS="Head2"><A NAME="pgfId-7021"></A>7.5.1	<A NAME="marker-54559"></A>aaload</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7022"></A>Load reference from array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7023"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-997849"></A><I CLASS="Variable">aaload</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7025"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7026"></A>aaload = 36 (0x24)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7027"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7028"></A>..., arrayref, index -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7029"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7030"></A>The arrayref must be of type reference and must refer to an array whose components are of type reference. The index must be of type short. Both arrayref and index are popped from the operand stack. The reference value in the component of the array at index is retrieved and pushed onto the top of the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7031"></A>Runtime Exceptions
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7032"></A>If arrayref is null, aaload throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7033"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the aaload instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26607"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54243"></A>In some circumstances, the aaload instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-54253"></A>7.5.2	<A NAME="marker-54560"></A>aastore</H3>
<P CLASS="Paragraph"><A NAME="pgfId-50790"></A>Store into reference array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7036"></A>Format 
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18662"></A><I CLASS="Variable">aastore</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7038"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7039"></A>aastore = 55 (0x37)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7040"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7041"></A>..., arrayref, index, value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7042"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7043"></A>The arrayref must be of type reference and must refer to an array whose components are of type reference. The index must be of type short and the value must be of type reference. The arrayref, index and value are popped from the operand stack. The reference value is stored as the component of the array at index.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7044"></A>At runtime the type of value must be confirmed to be assignment compatible with the type of the components of the array referenced by arrayref. Assignment of a value of reference type S (source) to a variable of reference type T (target) is allowed only when the type S supports all of the operations defined on type T. The detailed rules follow:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48247"></A>If S is a class type, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48248"></A>If T is a class type, then S must be the same class as T, or S must be a subclass of T;
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-48249"></A>If T is an interface type, then S must implement interface T.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48250"></A>If S is an interface type<A NAME="fnote1"></A><A HREF="#pgfId-53399"  CLASS="footnote"><SUP>[1]</SUP></A>, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48251"></A>If T is a class type, then T must be Object (<A HREF="JCVM02lang.html#Classes" CLASS="XRef">Section 2.2.2.4, Classes</A>);
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-48356"></A>If T is an interface type, T must be the same interface as S or a superinterface of S.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48357"></A>If S is an array type, namely the type SC[], that is, an array of components of type SC, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48254"></A>If T is a class type, then T must be Object.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-48255"></A>If T is an array type, namely the type TC[], an array of components of type TC, then one of the following must be true:
</LI>
<P CLASS="Linebreak">
</P>
</UL>
</UL>
<P CLASS="ParaIndent2"><A NAME="pgfId-48256"></A>TC and SC are the same primitive type (<A HREF="JCVM03structVM.html#91374" CLASS="XRef">Section 3.1, Data Types and Values</A>&quot;).
</P>
<P CLASS="ParaIndent2"><A NAME="pgfId-48257"></A>TC and SC are reference types<A NAME="fnote2"></A><A HREF="#pgfId-53438"  CLASS="footnote"><SUP>[2]</SUP></A> (<A HREF="JCVM03structVM.html#91374" CLASS="XRef">Section 3.1, Data Types and Values</A>) with type SC assignable to TC, by these rules.
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-53387"></A>If T is an interface type, T must be one of the interfaces implemented by arrays.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-53391"></A>Runtime Exceptions
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7054"></A>If arrayref is null, aastore throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7055"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the aastore instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7056"></A>Otherwise, if arrayref is not null and the actual type of value is not assignment compatible with the actual type of the component of the array, aastore throws an ArrayStoreException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26626"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-50823"></A>In some circumstances, the aastore instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-50824"></A>7.5.3	<A NAME="marker-54561"></A>aconst_null</H3>
<P CLASS="Paragraph"><A NAME="pgfId-50825"></A>Push null
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7059"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18664"></A><I CLASS="Variable">aconst_null</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7061"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7062"></A>aconst_null = 1 (0x1)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7063"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7064"></A>... -&gt; 
<BR>..., null
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7065"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7066"></A>Push the null object reference onto the operand stack.
</P><H3 CLASS="Head2"><A NAME="pgfId-7067"></A>7.5.4	<A NAME="marker-54562"></A>aload</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7068"></A>Load reference from local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7069"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21334"></A><I CLASS="Variable">aload</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21336"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7072"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7073"></A>aload = 21 (0x15)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7074"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7075"></A>... -&gt;
<BR>..., objectref
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7076"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7077"></A>The index is an unsigned byte that must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variable at index must contain a reference. The objectref in the local variable at index is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7078"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7079"></A>The <KBD CLASS="Filename-Command">aload</KBD> instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the <KBD CLASS="Filename-Command">astore</KBD> instruction is intentional.
</P><H3 CLASS="Head2"><A NAME="pgfId-7080"></A>7.5.5	<A NAME="marker-54563"></A>aload_&lt;n&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7081"></A>Load reference from local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7082"></A>Format 
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18666"></A><I CLASS="Variable">aload_&lt;n&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7084"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7085"></A>aload_0 = 24 (0x18)
<BR>aload_1 = 25 (0x19)
<BR>aload_2 = 26 (0x1a)
<BR>aload_3 = 27 (0x1b)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7086"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7087"></A>... -&gt;
<BR>..., objectref
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7088"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7089"></A>The &lt;n&gt; must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variable at &lt;n&gt; must contain a reference. The objectref in the local variable at &lt;n&gt; is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7090"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7091"></A>An aload_&lt;n&gt; instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_&lt;n&gt; instruction is intentional.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7092"></A>Each of the aload_&lt;n&gt; instructions is the same as aload with an index of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.
</P><H3 CLASS="Head2"><A NAME="pgfId-7093"></A>7.5.6	<A NAME="marker-54564"></A>anewarray</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7094"></A>Create new array of reference
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7095"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18668"></A><I CLASS="Variable">anewarray</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18670"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18672"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7099"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7100"></A>anewarray = 145 (0x91)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7101"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7102"></A>..., count -&gt;
<BR>..., arrayref
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7103"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26384"></A>The count must be of type short. It is popped off the operand stack. The count represents the number of components of the array to be created. The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The item at that index in the constant pool must be of type CONSTANT_Classref (<A HREF="JCVM06cap.html#39801" CLASS="XRef">Section 6.7.1, CONSTANT_Classref</A>), a reference to a class or interface type. The reference is resolved. A new array with components of that type, of length count, is allocated from the heap, and a reference arrayref to this new array object is pushed onto the operand stack. All components of the new array are initialized to null, the default value for reference types.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7105"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7106"></A>If count is less than zero, the anewarray instruction throws a NegativeArraySizeException.
</P><H3 CLASS="Head2"><A NAME="pgfId-7107"></A>7.5.7	<A NAME="marker-54565"></A>areturn</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7108"></A>Return reference from method
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7109"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18674"></A><I CLASS="Variable">areturn</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7111"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7112"></A>areturn = 119 (0x77)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7113"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7114"></A>..., objectref -&gt;
<BR>[empty]
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7115"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7116"></A>The objectref must be of type reference. The objectref is popped from the operand stack of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>) and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7117"></A>The virtual machine then reinstates the frame of the invoker and returns control to the invoker.
</P><H3 CLASS="Head2"><A NAME="pgfId-7118"></A>7.5.8	<A NAME="marker-54566"></A>arraylength</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7119"></A>Get length of array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7120"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18676"></A><I CLASS="Variable">arraylength</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7122"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7123"></A>arraylength = 146 (0x92)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7124"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7125"></A>..., arrayref -&gt;
<BR>..., length
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7126"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7127"></A>The arrayref must be of type reference and must refer to an array. It is popped from the operand stack. The length of the array it references is determined. That length is pushed onto the top of the operand stack as a short.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7128"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7129"></A>If arrayref is null, the arraylength instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26645"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26646"></A>In some circumstances, the arraylength instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-7130"></A>7.5.9	<A NAME="marker-54567"></A>astore</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7131"></A>Store reference into local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7132"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21329"></A><I CLASS="Variable">astore</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21331"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7135"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7136"></A>astore = 40 (0x28)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7137"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7138"></A>..., objectref -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7139"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7140"></A>The index is an unsigned byte that must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The objectref on the top of the operand stack must be of type returnAddress or of type reference. The objectref is popped from the operand stack, and the value of the local variable at index is set to objectref.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7141"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7142"></A>The astore instruction is used with an objectref of type returnAddress when implementing Java's finally keyword. The aload instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the astore instruction is intentional.
</P><H3 CLASS="Head2"><A NAME="pgfId-7143"></A>7.5.10	<A NAME="marker-54568"></A>astore_&lt;n&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7144"></A>Store reference into local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7145"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18678"></A><I CLASS="Variable">astore_&lt;n&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7147"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7148"></A>astore_0 = 43 (0x2b)
<BR>astore_1 = 44 (0x2c)
<BR>astore_2 = 45 (0x2d)
<BR>astore_3 = 46 (0x2e)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7149"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7150"></A>..., objectref -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7151"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7152"></A>The &lt;n&gt; must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The objectref on the top of the operand stack must be of type returnAddress or of type reference. It is popped from the operand stack, and the value of the local variable at &lt;n&gt; is set to objectref.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7153"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7154"></A>An astore_&lt;n&gt; instruction is used with an objectref of type returnAddress when implementing Java's finally keyword. An aload_&lt;n&gt; instruction cannot be used to load a value of type returnAddress from a local variable onto the operand stack. This asymmetry with the corresponding astore_&lt;n&gt; instruction is intentional.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7155"></A>Each of the astore_&lt;n&gt; instructions is the same as astore with an index of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.
</P><H3 CLASS="Head2"><A NAME="pgfId-7156"></A>7.5.11	<A NAME="marker-54569"></A>athrow</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7157"></A>Throw exception or error
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7158"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18680"></A><I CLASS="Variable">athrow</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7160"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7161"></A>athrow = 147 (0x93)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7162"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7163"></A>..., objectref -&gt;
<BR>objectref
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7164"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7165"></A>The objectref must be of type reference and must refer to an object that is an instance of class Throwable or of a subclass of Throwable. It is popped from the operand stack. The objectref is then thrown by searching the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>) for the most recent catch clause that catches the class of objectref or one of its superclasses.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7166"></A>If a catch clause is found, it contains the location of the code intended to handle this exception. The pc register is reset to that location, the operand stack of the current frame is cleared, objectref is pushed back onto the operand stack, and execution continues. If no appropriate clause is found in the current frame, that frame is popped, the frame of its invoker is reinstated, and the objectref is rethrown.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7167"></A>If no catch clause is found that handles this exception, the virtual machine exits.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7168"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26543"></A>If objectref is null, athrow throws a NullPointerException instead of objectref.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26722"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1001784"></A>In some circumstances, the athrow instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-1001795"></A>7.5.12	<A NAME="marker-1001794"></A>baload</H3>
<P CLASS="Paragraph"><A NAME="pgfId-1001796"></A>Load byte or boolean from array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7172"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18682"></A><I CLASS="Variable">baload</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7174"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7175"></A>baload = 37 (0x25)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7176"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7177"></A>..., arrayref, index -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7178"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7179"></A>The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index must be of type short. Both arrayref and index are popped from the operand stack. The byte value in the component of the array at index is retrieved, sign-extended to a short value, and pushed onto the top of the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7180"></A>Runtime Exceptions
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26431"></A>If arrayref is null, baload throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26657"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the baload instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26663"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26664"></A>In some circumstances, the baload instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-26658"></A>7.5.13	<A NAME="marker-54571"></A>bastore</H3>
<P CLASS="Paragraph"><A NAME="pgfId-26659"></A>Store into byte or boolean array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7185"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18684"></A><I CLASS="Variable">bastore</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7187"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7188"></A>bastore = 56 (0x38)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7189"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7190"></A>..., arrayref, index, value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7191"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1001829"></A>The arrayref must be of type reference and must refer to an array whose components are of type byte or of type boolean. The index and value must both be of type short. The arrayref, index and value are popped from the operand stack. The short value is truncated to a byte and stored as the component of the array indexed by index.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1001830"></A>Runtime Exceptions
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1001831"></A>If arrayref is null, bastore throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7195"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the bastore instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26672"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26673"></A>In some circumstances, the bastore instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-7196"></A>7.5.14	<A NAME="marker-54572"></A>bipush</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7197"></A>Push byte
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7198"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18686"></A><I CLASS="Variable">bipush</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18688"></A><I CLASS="Variable">byte</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7201"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7202"></A>bipush = 18 (0x12)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7203"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7204"></A>... -&gt;
<BR>..., value.word1, value.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7205"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7206"></A>The immediate byte is sign-extended to an int, and the resulting value is pushed onto the operand stack.
</P>
<BR>
<HR NOSHADE SIZE=1>
<TABLE CLASS="TipNote" DIR="LTR" WIDTH="100%" SUMMARY="TipNote">
<COLGROUP SPAN="1" WIDTH="100%">
<TR ALIGN="left" VALIGN="top">
<TD ROWSPAN="1" COLSPAN="1" ABBR="TipNoteText">
<P CLASS="TipNote"><B CLASS="TipNote">Note - </B><A NAME="pgfId-50876"></A>If a virtual machine does not support the int data type, the bipush instruction will not be available.
</P>
</TD>
</TR>
</TABLE>
<HR NOSHADE SIZE=1>
<BR><H3 CLASS="Head2"><A NAME="pgfId-50877"></A>7.5.15	<A NAME="marker-54573"></A>bspush</H3>
<P CLASS="Paragraph"><A NAME="pgfId-50878"></A>Push byte
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7211"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18690"></A><I CLASS="Variable">bspush</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18692"></A><I CLASS="Variable">byte</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7214"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7215"></A>bspush = 16 (0x10)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7216"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7217"></A>... -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7218"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7219"></A>The immediate byte is sign-extended to a short, and the resulting value is pushed onto the operand stack.
</P><H3 CLASS="Head2"><A NAME="pgfId-7220"></A>7.5.16	<A NAME="marker-54574"></A>checkcast</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7221"></A>Check whether object is of given type
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7222"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18694"></A><I CLASS="Variable">checkcast</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18696"></A><I CLASS="Variable">atype</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18698"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18700"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7227"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7228"></A>checkcast = 148 (0x94)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7229"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7230"></A>..., objectref -&gt;
<BR>..., objectref
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7231"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7232"></A>The unsigned byte atype is a code that indicates if the type against which the object is being checked is an array type or a class type. It must take one of the following values or zero:
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR"><CAPTION CLASS="TableCaption"><A NAME="pgfId-1004231"> </A> TABLE 7-2 	Array Values </CAPTION>
<THEAD>
<TR>
<TH SCOPE="COL" ROWSPAN="1" COLSPAN="1" BGCOLOR="#CCCCCC">
<P CLASS="TableHead"><A NAME="pgfId-1004275"></A>Array Type
</P>
</TH>
<TH SCOPE="COL" ROWSPAN="1" COLSPAN="1" BGCOLOR="#CCCCCC">
<P CLASS="TableHead"><A NAME="pgfId-1004277"></A>atype
</P>
</TH>
</TR>
</THEAD>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004259"></A><KBD CLASS="Filename-Command">T_BOOLEAN</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004261"></A><KBD CLASS="Filename-Command">10</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004263"></A><KBD CLASS="Filename-Command">T_BYTE</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004265"></A><KBD CLASS="Filename-Command">11</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004267"></A><KBD CLASS="Filename-Command">T_SHORT</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004269"></A><KBD CLASS="Filename-Command">12</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004285"></A><KBD CLASS="Filename-Command">T_INT</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004287"></A><KBD CLASS="Filename-Command">13</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004289"></A><KBD CLASS="Filename-Command">T_REFERENCE</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004291"></A><KBD CLASS="Filename-Command">14</KBD>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7258"></A>If the value of atype is 10, 11, 12, or 13, the values of the indexbyte1 and indexbyte2 must be zero, and the value of atype indicates the array type against which to check the object. Otherwise the unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The item at that index in the constant pool must be of type CONSTANT_Classref (<A HREF="JCVM06cap.html#39801" CLASS="XRef">Section 6.7.1, CONSTANT_Classref</A>), a reference to a class or interface type. The reference is resolved. If the value of atype is 14, the object is checked against an array type that is an array of object references of the type of the resolved class. If the value of atype is zero, the object is checked against a class or interface type that is the resolved class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7259"></A>The objectref must be of type reference. If objectref is null or can be cast to the specified array type or the resolved class or interface type, the operand stack is unchanged; otherwise the checkcast instruction throws a ClassCastException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-50915"></A>The following rules are used to determine whether an objectref that is not null can be cast to the resolved type: if S is the class of the object referred to by objectref and T is the resolved class, array or interface type, checkcast determines whether objectref can be cast to type T as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48331"></A>If S is a class type, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48332"></A>If T is a class type, then S must be the same class as T, or S must be a subclass of T;
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-48272"></A>If T is an interface type, then S must implement interface T.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48273"></A>If S is an interface type<A NAME="fnote3"></A><A HREF="#pgfId-53478"  CLASS="footnote"><SUP>[3]</SUP></A>, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48274"></A>If T is a class type, then T must be Object (<A HREF="JCVM02lang.html#Classes" CLASS="XRef">Section 2.2.2.4, Classes</A>);
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-52940"></A>If T is an interface type, T must be the same interface as S or a superinterface of S.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48411"></A>If S is an array type, namely the type SC[], that is, an array of components of type SC, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48412"></A>If T is a class type, then T must be Object.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-48413"></A>If T is an array type, namely the type TC[], an array of components of type TC, then one of the following must be true:
</LI>
<P CLASS="Linebreak">
</P>
</UL>
</UL>
<P CLASS="ParaIndent2"><A NAME="pgfId-48414"></A>TC and SC are the same primitive type (<A HREF="JCVM03structVM.html#91374" CLASS="XRef">Section 3.1, Data Types and Values</A>).
</P>
<P CLASS="ParaIndent2"><A NAME="pgfId-48415"></A>TC and SC are reference types<A NAME="fnote4"></A><A HREF="#pgfId-53447"  CLASS="footnote"><SUP>[4]</SUP></A> (<A HREF="JCVM03structVM.html#91374" CLASS="XRef">Section 3.1, Data Types and Values</A>) with type SC assignable to TC, by these rules.
</P>
<UL>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-53010"></A>If T is an interface type, T must be one of the interfaces implemented by arrays.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-53014"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26511"></A>If objectref cannot be cast to the resolved class, array, or interface type, the checkcast instruction throws a ClassCastException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7272"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7273"></A>The checkcast instruction is fundamentally very similar to the instanceof instruction. It differs in its treatment of null, its behavior when its test fails (checkcast throws an exception, instanceof pushes a result code), and its effect on the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1003337"></A>In some circumstances, the checkcast instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7274"></A>If a virtual machine does not support the int data type, the value of atype may not be 13 (array type = T_INT).
</P><H3 CLASS="Head2"><A NAME="pgfId-7275"></A>7.5.17	<A NAME="marker-54575"></A>dup</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7276"></A>Duplicate top operand stack word
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7277"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18702"></A><I CLASS="Variable">dup</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7279"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7280"></A>dup = 61 (0x3d)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7281"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7282"></A>..., word -&gt;
<BR>..., word, word
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7283"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7284"></A>The top word on the operand stack is duplicated and pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7285"></A>The dup instruction must not be used unless word contains a 16-bit data type.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7286"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1001940"></A>Except for restrictions preserving the integrity of 32-bit data types, the dup instruction operates on an untyped word, ignoring the type of data it contains.
</P><H3 CLASS="Head2"><A NAME="pgfId-1001942"></A>7.5.18	<A NAME="marker-1001941"></A>dup_x</H3>
<P CLASS="Paragraph"><A NAME="pgfId-1001943"></A>Duplicate top operand stack words and insert below
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7290"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18704"></A><I CLASS="Variable">dup_x</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18706"></A><I CLASS="Variable">mn</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7293"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7294"></A>dup_x = 63 (0x3f)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7295"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7296"></A>..., wordN, ..., wordM, ..., word1 -&gt;
<BR>..., wordM, ..., word1, wordN, ..., wordM, ..., word1
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7297"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7298"></A>The unsigned byte mn is used to construct two parameter values. The high nibble, (mn &amp; 0xf0) &gt;&gt; 4, is used as the value m. The low nibble, (mn &amp; 0xf), is used as the value n. Permissible values for m are 1 through 4. Permissible values for n are 0 and m through m+4.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7299"></A>For positive values of n, the top m words on the operand stack are duplicated and the copied words are inserted n words down in the operand stack. When n equals 0, the top m words are copied and placed on top of the stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7300"></A>The dup_x instruction must not be used unless the ranges of words 1 through m and words m+1 through n each contain either a 16-bit data type, two 16-bit data types, a 32-bit data type, a 16-bit data type and a 32-bit data type (in either order), or two 32-bit data types.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7301"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7302"></A>Except for restrictions preserving the integrity of 32-bit data types, the dup_x instruction operates on untyped words, ignoring the types of data they contain.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7303"></A>If a virtual machine does not support the int data type, the permissible values for m are 1 or 2, and permissible values for n are 0 and m through m+2.
</P><H3 CLASS="Head2"><A NAME="pgfId-7304"></A>7.5.19	<A NAME="marker-54577"></A>dup2</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7305"></A>Duplicate top two operand stack words
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7306"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18709"></A><I CLASS="Variable">dup2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7308"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7309"></A>dup2 = 62 (0x3e)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7310"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7311"></A>..., word2, word1 -&gt;
<BR>..., word2, word1, word2, word1
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7312"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7313"></A>The top two words on the operand stack are duplicated and pushed onto the operand stack, in the original order.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7314"></A>The dup2 instruction must not be used unless each of word1 and word2 is a word that contains a 16-bit data type or both together are the two words of a single 32-bit datum.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7315"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7316"></A>Except for restrictions preserving the integrity of 32-bit data types, the dup2 instruction operates on untyped words, ignoring the types of data they contain.
</P><H3 CLASS="Head2"><A NAME="pgfId-7317"></A>7.5.20	<A NAME="marker-54578"></A>getfield_&lt;t&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7318"></A>Fetch field from object
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7319"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18712"></A><I CLASS="Variable">getfield_&lt;t&gt;</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18714"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7322"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7323"></A>getfield_a = 131 (0x83)
<BR>getfield_b = 132 (0x84)
<BR>getfield_s = 133 (0x85)
<BR>getfield_i = 134 (0x86)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7324"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7325"></A>..., objectref -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7326"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7327"></A>..., objectref -&gt;
<BR>..., value.word1, value.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7328"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1003357"></A>The objectref, which must be of type reference, is popped from the operand stack. The unsigned index is used as an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The constant pool item at the index must be of type CONSTANT_InstanceFieldref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to a class and a field token.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1003364"></A>The class of objectref must not be an array. If the field is protected, and it is a member of a superclass of the current class, and the field is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7330"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7331"></A>a  field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1001991"></A>b  field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1001992"></A>s  field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1001993"></A>i  field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7335"></A>The width of a field in a class instance is determined by the field type specified in the instruction. The item is resolved, determining the field offset<A NAME="fnote5"></A><A HREF="#pgfId-53110"  CLASS="footnote"><SUP>[5]</SUP></A>. The value at that offset into the class instance referenced by objectref is fetched. If the value is of type byte or type boolean, it is sign-extended to a short. The value is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7336"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26694"></A>If objectref is null, the getfield_&lt;t&gt; instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26695"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26696"></A>In some circumstances, the getfield_&lt;t&gt; instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26697"></A>If a virtual machine does not support the int data type, the getfield_i instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7340"></A>7.5.21	<A NAME="marker-54579"></A>getfield_&lt;t&gt;_this</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7341"></A>Fetch field from current object
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7342"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18717"></A><I CLASS="Variable">getfield_&lt;t&gt;_this</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18719"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7345"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7346"></A>getfield_a_this = 173 (0xad)
<BR>getfield_b_this = 174 (0xae)
<BR>getfield_s_this = 175 (0xaf)
<BR>getfield_i_this = 176 (0xb0)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7347"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7348"></A>... -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7349"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7350"></A>... -&gt;
<BR>..., value.word1, value.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7351"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7352"></A>The currently executing method must be an instance method. The local variable at index 0 must contain a reference objectref to the currently executing method's this parameter. The unsigned index is used as an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The constant pool item at the index must be of type CONSTANT_InstanceFieldref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to a class and a field token.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54012"></A>The class of objectref must not be an array. If the field is protected, and it is a member of a superclass of the current class, and the field is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7353"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7354"></A>a  field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7355"></A>b  field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7356"></A>s  field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7357"></A>i  field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7358"></A>The width of a field in a class instance is determined by the field type specified in the instruction. The item is resolved, determining the field offset<A NAME="fnote6"></A><A HREF="#pgfId-53123"  CLASS="footnote"><SUP>[6]</SUP></A>. The value at that offset into the class instance referenced by objectref is fetched. If the value is of type byte or type boolean, it is sign-extended to a short. The value is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7359"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7360"></A>If objectref is null, the getfield_&lt;t&gt;_this instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26709"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26710"></A>In some circumstances, the getfield_&lt;t&gt;_this instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54814"></A>If a virtual machine does not support the int data type, the getfield_i_this instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-54816"></A>7.5.22	<A NAME="marker-54815"></A>getfield_&lt;t&gt;_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-54817"></A>Fetch field from object (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7365"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18722"></A><I CLASS="Variable">getfield_&lt;t&gt;_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18724"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18726"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7369"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7370"></A>getfield_a_w = 169 (0xa9)
<BR>getfield_b_w = 170 (0xaa)
<BR>getfield_s_w = 171 (0xab)
<BR>getfield_i_w = 172 (0xac)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7371"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7372"></A>..., objectref -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7373"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7374"></A>..., objectref -&gt;
<BR>..., value.word1, value.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7375"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53862"></A>The objectref, which must be of type reference, is popped from the operand stack. The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The constant pool item at the index must be of type CONSTANT_InstanceFieldref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to a class and a field token. The item must resolve to a field of type reference.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54021"></A>The class of objectref must not be an array. If the field is protected, and it is a member of a superclass of the current class, and the field is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7377"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7378"></A>a  field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7379"></A>b  field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7380"></A>s  field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7381"></A>i  field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7382"></A>The width of a field in a class instance is determined by the field type specified in the instruction. The item is resolved, determining the field offset<A NAME="fnote7"></A><A HREF="#pgfId-53130"  CLASS="footnote"><SUP>[7]</SUP></A>. The value at that offset into the class instance referenced by objectref is fetched. If the value is of type byte or type boolean, it is sign-extended to a short. The value is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7383"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7384"></A>If objectref is null, the getfield_&lt;t&gt;_w instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26742"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26743"></A>In some circumstances, the getfield_&lt;t&gt;_w instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context <A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7386"></A>If a virtual machine does not support the int data type, the getfield_i_w instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7387"></A>7.5.23	<A NAME="marker-54581"></A>getstatic_&lt;t&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7388"></A>Get static field from class
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7389"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18729"></A><I CLASS="Variable">getstatic_&lt;t&gt;</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18731"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18733"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7393"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7394"></A>getstatic_a = 123 (0x7b)
<BR>getstatic_b = 124 (0x7c)
<BR>getstatic_s = 125 (0x7d)
<BR>getstatic_i = 126 (0x7e)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7395"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7396"></A>... -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7397"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7398"></A>... -&gt;
<BR>..., value.word1, value.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7399"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7400"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The constant pool item at the index must be of type CONSTANT_StaticFieldref (<A HREF="JCVM06cap.html#21307" CLASS="XRef">Section 6.7.3, CONSTANT_StaticFieldref and CONSTANT_StaticMethodref</A>), a reference to a static field.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7401"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7402"></A>	a field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7403"></A>	b field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7404"></A>	s field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7405"></A>	i field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-50990"></A>The width of a class field is determined by the field type specified in the instruction. The item is resolved, determining the field offset. The item is resolved, determining the class field. The value of the class field is fetched. If the value is of type byte or boolean, it is sign-extended to a short. The value is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-50991"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-50992"></A>If a virtual machine does not support the int data type, the getstatic_i instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7409"></A>7.5.24	<A NAME="marker-54582"></A>goto</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7410"></A>Branch always
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7411"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18740"></A><I CLASS="Variable">goto</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18742"></A><I CLASS="Variable">branch</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7414"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7415"></A>goto = 112 (0x70)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7416"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7417"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7418"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7419"></A>The value branch is used as a signed 8-bit offset. Execution proceeds at that offset from the address of the opcode of this goto instruction. The target address must be that of an opcode of an instruction within the method that contains this goto instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7420"></A>7.5.25	<A NAME="marker-54583"></A>goto_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7421"></A>Branch always (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7422"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18745"></A><I CLASS="Variable">goto_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18747"></A><I CLASS="Variable">branchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18749"></A><I CLASS="Variable">branchbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7426"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7427"></A>goto_w = 168 (0xa8)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7428"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7429"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7430"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7431"></A>The unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 &lt;&lt; 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this goto instruction. The target address must be that of an opcode of an instruction within the method that contains this goto instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7432"></A>7.5.26	<A NAME="marker-54584"></A>i2b</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7433"></A>Convert int to byte
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7434"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18752"></A><I CLASS="Variable">i2b</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7436"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7437"></A>i2b = 93 (0x5d)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7438"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7439"></A>..., value.word1, value.word2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7440"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7441"></A>The value on top of the operand stack must be of type int. It is popped from the operand stack and converted to a byte result by taking the low-order 16 bits of the int value, and discarding the high-order 16 bits. The low-order word is truncated to a byte, then sign-extended to a short result. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7442"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7443"></A>The i2b instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value. The result may also not have the same sign as value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7444"></A>If a virtual machine does not support the int data type, the i2b instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7445"></A>7.5.27	<A NAME="marker-54585"></A>i2s</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7446"></A>Convert int to short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7447"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18755"></A><I CLASS="Variable">i2s</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7449"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7450"></A>i2s = 94 (0x5e)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7451"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7452"></A>..., value.word1, value.word2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7453"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7454"></A>The value on top of the operand stack must be of type int. It is popped from the operand stack and converted to a short result by taking the low-order 16 bits of the int value and discarding the high-order 16 bits. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7455"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7456"></A>The i2s instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value. The result may also not have the same sign as value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7457"></A>If a virtual machine does not support the int data type, the i2s instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7458"></A>7.5.28	<A NAME="marker-54586"></A>iadd</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7459"></A>Add int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7460"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18758"></A><I CLASS="Variable">iadd</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7462"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7463"></A>iadd = 66 (0x42)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7464"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7465"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7466"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7467"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 + value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7468"></A>If an iadd instruction overflows, then the result is the low-order bits of the true mathematical result in a sufficiently wide two's-complement format. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7469"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7470"></A>If a virtual machine does not support the int data type, the iadd instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7471"></A>7.5.29	<A NAME="marker-54587"></A>iaload</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7472"></A>Load int from array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7473"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18761"></A><I CLASS="Variable">iaload</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7475"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7476"></A>iaload = 39 (0x27)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7477"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7478"></A>..., arrayref, index -&gt;
<BR>..., value.word1, value.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7479"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7480"></A>The arrayref must be of type reference and must refer to an array whose components are of type int. The index must be of type short. Both arrayref and index are popped from the operand stack. The int value in the component of the array at index is retrieved and pushed onto the top of the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7481"></A>Runtime Exceptions
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7482"></A>If arrayref is null, iaload throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7483"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the iaload instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26898"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26899"></A>In some circumstances, the iaload instruction may throw a SecurityException if the current context <A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7485"></A>If a virtual machine does not support the int data type, the iaload instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7486"></A>7.5.30	<A NAME="marker-54588"></A>iand</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7487"></A>Boolean AND int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7488"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18764"></A><I CLASS="Variable">iand</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7490"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7491"></A>iand = 84 (0x54)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7492"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7493"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7494"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7495"></A>Both value1 and value2 must be of type int. They are popped from the operand stack. An int result is calculated by taking the bitwise AND (conjunction) of value1 and value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7496"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7497"></A>If a virtual machine does not support the int data type, the iand instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7498"></A>7.5.31	<A NAME="marker-54589"></A>iastore</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7499"></A>Store into int array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7500"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18767"></A><I CLASS="Variable">iastore</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7502"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7503"></A>iastore = 58 (0x3a)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7504"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7505"></A>..., arrayref, index, value.word1, value.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7506"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7507"></A>The arrayref must be of type reference and must refer to an array whose components are of type int. The index must be of type short and value must be of type int. The arrayref, index and value are popped from the operand stack. The int value is stored as the component of the array indexed by index.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7508"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7509"></A>If arrayref is null, iastore throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7510"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the iastore instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26909"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26910"></A>In some circumstances, the iastore instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7512"></A>If a virtual machine does not support the int data type, the iastore instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7513"></A>7.5.32	<A NAME="marker-54590"></A>icmp</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7514"></A>Compare int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7515"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18770"></A><I CLASS="Variable">icmp</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7517"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7518"></A>icmp = 95 (0x5f)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7519"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7520"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7521"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7522"></A>Both value1 and value2 must be of type int. They are both popped from the operand stack, and a signed integer comparison is performed. If value1 is greater than value2, the short value 1 is pushed onto the operand stack. If value1 is equal to value2, the short value 0 is pushed onto the operand stack. If value1 is less than value2, the short value -1 is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7523"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7524"></A>If a virtual machine does not support the int data type, the icmp instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7525"></A>7.5.33	<A NAME="marker-54591"></A>iconst_&lt;i&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7526"></A>Push int constant
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7527"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18773"></A><I CLASS="Variable">iconst_&lt;i&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7529"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7530"></A>iconst_m1 = 10 (0x09)
<BR>iconst_0 = 11 (0xa)
<BR>iconst_1 = 12 (0xb)
<BR>iconst_2 = 13 (0xc)
<BR>iconst_3 = 14 (0xd)
<BR>iconst_4 = 15 (0xe)
<BR>iconst_5 = 16 (0xf)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7531"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7532"></A>... -&gt;
<BR>..., &lt;i&gt;.word1, &lt;i&gt;.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7533"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7534"></A>Push the int constant &lt;i&gt; (-1, 0, 1, 2, 3, 4, or 5) onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7535"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7536"></A>If a virtual machine does not support the int data type, the iconst_&lt;i&gt; instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7537"></A>7.5.34	<A NAME="marker-54592"></A>idiv</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7538"></A>Divide int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7539"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18776"></A><I CLASS="Variable">idiv</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7541"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7542"></A>idiv = 72 (0x48)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7543"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7544"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7545"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7546"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is the value of the Java expression value1 / value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7547"></A>An int division rounds towards 0; that is, the quotient produced for int values in n/d is an int value q whose magnitude is as large as possible while satisfying | d &#183; q | &lt;= | n |. Moreover, q is a positive when | n | &gt;= | d | and n and d have the same sign, but q is negative when | n | &gt;= | d | and n and d have opposite signs.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7548"></A>There is one special case that does not satisfy this rule: if the dividend is the negative integer of the largest possible magnitude for the int type, and the divisor is -1, then overflow occurs, and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7549"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7550"></A>If the value of the divisor in an int division is 0, idiv throws an ArithmeticException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7551"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7552"></A>If a virtual machine does not support the int data type, the idiv instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7553"></A>7.5.35	<A NAME="marker-54593"></A>if_acmp&lt;cond&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7554"></A>Branch if reference comparison succeeds.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7555"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18779"></A><I CLASS="Variable">if_acmp&lt;cond&gt;</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18781"></A><I CLASS="Variable">branch</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7558"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7559"></A>if_acmpeq = 104 (0x68)
<BR>if_acmpne = 105 (0x69)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7560"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7561"></A>..., value1, value2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7562"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7563"></A>Both value1 and value2 must be of type reference. They are both popped from the operand stack and compared. The results of the comparisons are as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7564"></A>eq  succeeds if and only if value1 = value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7565"></A>ne  succeeds if and only if value1  value2
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7566"></A>If the comparison succeeds, branch is used as signed 8-bit offset, and execution proceeds at that offset from the address of the opcode of this if_acmp&lt;cond&gt; instruction. The target address must be that of an opcode of an instruction within the method that contains this if_acmp&lt;cond&gt; instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7567"></A>Otherwise, execution proceeds at the address of the instruction following this if_acmp&lt;cond&gt; instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7568"></A>7.5.36	<A NAME="marker-54594"></A>if_acmp&lt;cond&gt;_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7569"></A>Branch if reference comparison succeeds (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7570"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18784"></A><I CLASS="Variable">if_acmp&lt;cond&gt;_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18786"></A><I CLASS="Variable">branchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18788"></A><I CLASS="Variable">branchbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7574"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7575"></A>if_acmpeq_w = 160 (0xa0)
<BR>if_acmpne_w = 161 (0xa1)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7576"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7577"></A>..., value1, value2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7578"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7579"></A>Both value1 and value2 must be of type reference. They are both popped from the operand stack and compared. The results of the comparisons are as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7580"></A>eq   succeeds if and only if value1 = value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7581"></A>ne  succeeds if and only if value1  value2
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7582"></A>If the comparison succeeds, the unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 &lt;&lt; 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this if_acmp&lt;cond&gt;_w instruction. The target address must be that of an opcode of an instruction within the method that contains this if_acmp&lt;cond&gt;_w instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7583"></A>Otherwise, execution proceeds at the address of the instruction following this if_acmp&lt;cond&gt;_w instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7584"></A>7.5.37	<A NAME="marker-54595"></A>if_scmp&lt;cond&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7585"></A>Branch if short comparison succeeds
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7586"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18791"></A><I CLASS="Variable">if_scmp&lt;cond&gt;</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18793"></A><I CLASS="Variable">branch</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7589"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7590"></A>if_scmpeq = 106 (0x6a)
<BR>if_scmpne = 107 (0x6b)
<BR>if_scmplt = 108 (0x6c)
<BR>if_scmpge = 109 (0x6d)
<BR>if_scmpgt = 110 (0x6e)
<BR>if_scmple = 111 (0x6f)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7591"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7592"></A>..., value1, value2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7593"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7594"></A>Both value1 and value2 must be of type short. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparisons are as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7595"></A>eq  succeeds if and only if value1 = value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7596"></A>ne  succeeds if and only if value1  value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7597"></A>lt  succeeds if and only if value1 &lt; value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7598"></A>le  succeeds if and only if value1 &#163; value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7599"></A>gt  succeeds if and only if value1 &gt; value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7600"></A>ge  succeeds if and only if value1 &#8805; value2
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7601"></A>If the comparison succeeds, branch is used as signed 8-bit offset, and execution proceeds at that offset from the address of the opcode of this if_scmp&lt;cond&gt; instruction. The target address must be that of an opcode of an instruction within the method that contains this if_scmp&lt;cond&gt; instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7602"></A>Otherwise, execution proceeds at the address of the instruction following this if_scmp&lt;cond&gt; instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7603"></A>7.5.38	<A NAME="marker-54596"></A>if_scmp&lt;cond&gt;_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7604"></A>Branch if short comparison succeeds (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7605"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18983"></A><I CLASS="Variable">if_scmp&lt;cond&gt;_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18985"></A><I CLASS="Variable">branchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18987"></A><I CLASS="Variable">branchbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7609"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7610"></A>if_scmpeq_w = 162 (0xa2)
<BR>if_scmpne_w = 163 (0xa3)
<BR>if_scmplt_w = 164 (0xa4)
<BR>if_scmpge_w = 165 (0xa5)
<BR>if_scmpgt_w = 166 (0xa6)
<BR>if_scmple_w = 167 (0xa7)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7611"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7612"></A>..., value1, value2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7613"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7614"></A>Both value1 and value2 must be of type short. They are both popped from the operand stack and compared. All comparisons are signed. The results of the comparisons are as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-1002295"></A>eq  succeeds if and only if value1 = value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1002296"></A>ne  succeeds if and only if value1  value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1002297"></A>lt  succeeds if and only if value1 &lt; value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7618"></A>le  succeeds if and only if value1 &#163; value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7619"></A>gt  succeeds if and only if value1 &gt; value2
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7620"></A>ge  succeeds if and only if value1 &#8805; value2
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7621"></A>If the comparison succeeds, the unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 &lt;&lt; 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this if_scmp&lt;cond&gt;_w instruction. The target address must be that of an opcode of an instruction within the method that contains this if_scmp&lt;cond&gt;_w instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7622"></A>Otherwise, execution proceeds at the address of the instruction following this if_scmp&lt;cond&gt;_w instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7623"></A>7.5.39	<A NAME="marker-54597"></A>if&lt;cond&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7624"></A>Branch if short comparison with zero succeeds
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7625"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18990"></A><I CLASS="Variable">if&lt;cond&gt;</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18992"></A><I CLASS="Variable">branch</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7628"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7629"></A>ifeq = 96 (0x60)
<BR>ifne = 97 (0x61)
<BR>iflt = 98 (0x62)
<BR>ifge = 99 (0x63)
<BR>ifgt = 100 (0x64)
<BR>ifle = 101 (0x65)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7630"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7631"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7632"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7633"></A>The value must be of type short. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-7634"></A>eq  succeeds if and only if value = 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7635"></A>ne  succeeds if and only if value  0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-27088"></A>lt  succeeds if and only if value &lt; 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-27089"></A>le  succeeds if and only if value &#163; 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-27090"></A>gt  succeeds if and only if value &gt; 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7639"></A>ge  succeeds if and only if value &#8805; 0
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7640"></A>If the comparison succeeds, branch is used as signed 8-bit offset, and execution proceeds at that offset from the address of the opcode of this if&lt;cond&gt; instruction. The target address must be that of an opcode of an instruction within the method that contains this if&lt;cond&gt; instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7641"></A>Otherwise, execution proceeds at the address of the instruction following this if&lt;cond&gt; instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7642"></A>7.5.40	<A NAME="marker-54598"></A>if&lt;cond&gt;_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7643"></A>Branch if short comparison with zero succeeds (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7644"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18995"></A><I CLASS="Variable">if&lt;cond&gt;_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18997"></A><I CLASS="Variable">branchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18999"></A><I CLASS="Variable">branchbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7648"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7649"></A>ifeq_w = 152 (0x98)
<BR>ifne_w = 153 (0x99)
<BR>iflt_w = 154 (0x9a)
<BR>ifge_w = 155 (0x9b)
<BR>ifgt_w = 156 (0x9c)
<BR>ifle_w = 157 (0x9d)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7650"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7651"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7652"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1002337"></A>The value must be of type short. It is popped from the operand stack and compared against zero. All comparisons are signed. The results of the comparisons are as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-1002338"></A>eq  succeeds if and only if value = 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1002339"></A>ne  succeeds if and only if value  0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7656"></A>lt  succeeds if and only if value &lt; 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7657"></A>le  succeeds if and only if value &#163; 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7658"></A>gt  succeeds if and only if value &gt; 0
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-7659"></A>ge  succeeds if and only if value &#8805; 0
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7660"></A>If the comparison succeeds, the unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 &lt;&lt; 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this if&lt;cond&gt;_w instruction. The target address must be that of an opcode of an instruction within the method that contains this if&lt;cond&gt;_w instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7661"></A>Otherwise, execution proceeds at the address of the instruction following this if&lt;cond&gt;_w instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7662"></A>7.5.41	<A NAME="marker-54599"></A>ifnonnull</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7663"></A>Branch if reference not null
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7664"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19002"></A><I CLASS="Variable">ifnonnull</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19004"></A><I CLASS="Variable">branch</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7667"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7668"></A>ifnonnull = 103 (0x67)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7669"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7670"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7671"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7672"></A>The value must be of type reference. It is popped from the operand stack. If the value is not null, branch is used as signed 8-bit offset, and execution proceeds at that offset from the address of the opcode of this ifnonnull instruction. The target address must be that of an opcode of an instruction within the method that contains this ifnonnull instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7673"></A>Otherwise, execution proceeds at the address of the instruction following this ifnonnull instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7674"></A>7.5.42	<A NAME="marker-54600"></A>ifnonnull_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7675"></A>Branch if reference not null (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7676"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19007"></A><I CLASS="Variable">ifnonnull_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19009"></A><I CLASS="Variable">branchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19011"></A><I CLASS="Variable">branchbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7680"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7681"></A>ifnonnull_w = 159 (0x9f)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7682"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7683"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7684"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7685"></A>The value must be of type reference. It is popped from the operand stack. If the value is not null, the unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 &lt;&lt; 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this ifnonnull_w instruction. The target address must be that of an opcode of an instruction within the method that contains this ifnonnull_w instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7686"></A>Otherwise, execution proceeds at the address of the instruction following this ifnonnull_w instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7687"></A>7.5.43	i<A NAME="marker-54601"></A>fnull</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7688"></A>Branch if reference is null
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7689"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19014"></A><I CLASS="Variable">ifnull</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19016"></A><I CLASS="Variable">branch</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7692"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7693"></A>ifnull = 102 (0x66)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7694"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7695"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7696"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7697"></A>The value must be of type reference. It is popped from the operand stack. If the value is null, branch is used as signed 8-bit offset, and execution proceeds at that offset from the address of the opcode of this ifnull instruction. The target address must be that of an opcode of an instruction within the method that contains this ifnull instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7698"></A>Otherwise, execution proceeds at the address of the instruction following this ifnull instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7699"></A>7.5.44	<A NAME="marker-54602"></A>ifnull_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7700"></A>Branch if reference is null (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7701"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19019"></A><I CLASS="Variable">ifnull_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19021"></A><I CLASS="Variable">branchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19023"></A><I CLASS="Variable">branchbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7705"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7706"></A>ifnull_w = 158 (0x9e)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7707"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7708"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7709"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7710"></A>The value must be of type reference. It is popped from the operand stack. If the value is null, the unsigned bytes branchbyte1 and branchbyte2 are used to construct a signed 16-bit branchoffset, where branchoffset is (branchbyte1 &lt;&lt; 8) | branchbyte2. Execution proceeds at that offset from the address of the opcode of this ifnull_w instruction. The target address must be that of an opcode of an instruction within the method that contains this ifnull_w instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7711"></A>Otherwise, execution proceeds at the address of the instruction following this ifnull_w instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-7712"></A>7.5.45	<A NAME="marker-54603"></A>iinc</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7713"></A>Increment local int variable by constant
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7714"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19026"></A><I CLASS="Variable">iinc</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19028"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19030"></A><I CLASS="Variable">const</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7718"></A>Forms 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7719"></A>iinc = 90 (0x5a)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7720"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7721"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7722"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7723"></A>The index is an unsigned byte. Both index and index + 1 must be valid indices into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variables at index and index + 1 together must contain an int. The const is an immediate signed byte. The value const is first sign-extended to an int, then the int contained in the local variables at index and index + 1 is incremented by that amount.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7724"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7725"></A>If a virtual machine does not support the int data type, the iinc instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7726"></A>7.5.46	<A NAME="marker-54604"></A>iinc_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7727"></A>Increment local int variable by constant
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7728"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19033"></A><I CLASS="Variable">iinc_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19035"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19037"></A><I CLASS="Variable">byte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19039"></A><I CLASS="Variable">byte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7733"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7734"></A>iinc_w = 151 (0x97)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7735"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7736"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7737"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7738"></A>The index is an unsigned byte. Both index and index + 1 must be valid indices into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variables at index and index + 1 together must contain an int. The immediate unsigned byte1 and byte2 values are assembled into an intermediate short where the value of the short is (byte1 &lt;&lt; 8) | byte2. The intermediate value is then sign-extended to an int const. The int contained in the local variables at index and index + 1 is incremented by const.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7739"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7740"></A>If a virtual machine does not support the int data type, the iinc_w instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7741"></A>7.5.47	<A NAME="marker-54605"></A>iipush</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7742"></A>Push int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7743"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19042"></A><I CLASS="Variable">iipush</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19044"></A><I CLASS="Variable">byte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19046"></A><I CLASS="Variable">byte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19048"></A><I CLASS="Variable">byte3</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19050"></A><I CLASS="Variable">byte4</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7749"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7750"></A>iipush = 20 (0x14)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7751"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7752"></A>... -&gt;
<BR>..., value1.word1, value1.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7753"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7754"></A>The immediate unsigned byte1, byte2, byte3, and byte4 values are assembled into a signed int where the value of the int is (byte1 &lt;&lt; 24) | (byte2 &lt;&lt; 16) | (byte3 &lt;&lt; 8) | byte4. The resulting value is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7755"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7756"></A>If a virtual machine does not support the int data type, the iipush instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7757"></A>7.5.48	<A NAME="marker-54606"></A>iload</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7758"></A>Load int from local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7759"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19053"></A><I CLASS="Variable">iload</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19055"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7762"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7763"></A>iload = 23 (0x17)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7764"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7765"></A>... -&gt;
<BR>..., value1.word1, value1.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7766"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7767"></A>The index is an unsigned byte. Both index and index + 1 must be valid indices into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variables at index and index + 1 together must contain an int. The value of the local variables at index and index + 1 is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7768"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7769"></A>If a virtual machine does not support the int data type, the iload instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7770"></A>7.5.49	<A NAME="marker-54607"></A>iload_&lt;n&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7771"></A>Load int from local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7772"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19058"></A><I CLASS="Variable">iload_&lt;n&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7774"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7775"></A>iload_0 = 32 (0x20)
<BR>iload_1 = 33 (0x21)
<BR>iload_2 = 34 (0x22)
<BR>iload_3 = 35 (0x23)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7776"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7777"></A>... -&gt;
<BR>..., value1.word1, value1.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7778"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7779"></A>Both &lt;n&gt; and &lt;n&gt; + 1 must be a valid indices into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variables at &lt;n&gt; and &lt;n&gt; + 1 together must contain an int. The value of the local variables at &lt;n&gt; and &lt;n&gt; + 1 is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7780"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7781"></A>Each of the iload_&lt;n&gt; instructions is the same as iload with an index of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7782"></A>If a virtual machine does not support the int data type, the iload_&lt;n&gt; instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7783"></A>7.5.50	<A NAME="marker-54608"></A>ilookupswitch</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7784"></A>Access jump table by key match and jump
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7785"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19061"></A><I CLASS="Variable">ilookupswitch</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19063"></A><I CLASS="Variable">defaultbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19065"></A><I CLASS="Variable">defaultbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19067"></A><I CLASS="Variable">npairs1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19069"></A><I CLASS="Variable">npairs2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19071"></A><I CLASS="Variable">match-offset pairs</I>...
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-25697"></A>Pair Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25716"></A><I CLASS="Variable">matchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25718"></A><I CLASS="Variable">matchbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25720"></A><I CLASS="Variable">matchbyte3</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25722"></A><I CLASS="Variable">matchbyte4</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25724"></A><I CLASS="Variable">offsetbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25726"></A><I CLASS="Variable">offsetbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7799"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7800"></A>ilookupswitch = 118 (0x76)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7801"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7802"></A>..., key.word1, key.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7803"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7804"></A>An ilookupswitch instruction is a variable-length instruction. Immediately after the ilookupswitch opcode follow a signed 16-bit value default, an unsigned 16-bit value npairs, and then npairs pairs. Each pair consists of an int match and a signed 16-bit offset. Each match is constructed from four unsigned bytes as (matchbyte1 &lt;&lt; 24) | (matchbyte2 &lt;&lt; 16) | (matchbyte3 &lt;&lt; 8) | matchbyte4. Each offset is constructed from two unsigned bytes as (offsetbyte1 &lt;&lt; 8) | offsetbyte2.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7805"></A>The table match-offset pairs of the ilookupswitch instruction must be sorted in increasing numerical order by match.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7806"></A>The key must be of type int and is popped from the operand stack and compared against the match values. If it is equal to one of them, then a target address is calculated by adding the corresponding offset to the address of the opcode of this ilookupswitch instruction. If the key does not match any of the match values, the target address is calculated by adding default to the address of the opcode of this ilookupswitch instruction. Execution then continues at the target address.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7807"></A>The target address that can be calculated from the offset of each match-offset pair, as well as the one calculated from default, must be the address of an opcode of an instruction within the method that contains this ilookupswitch instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7808"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7809"></A>The match-offset pairs are sorted to support lookup routines that are quicker than linear search.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7810"></A>If a virtual machine does not support the int data type, the ilookupswitch instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7811"></A>7.5.51	<A NAME="marker-54609"></A>imul</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7812"></A>Multiply int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7813"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19074"></A><I CLASS="Variable">imul</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7815"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7816"></A>imul = 70 (0x46)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7817"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7818"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7819"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7820"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 * value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7821"></A>If an imul instruction overflows, then the result is the low-order bits of the mathematical product as an int. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two values.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7822"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7823"></A>If a virtual machine does not support the int data type, the imul instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7824"></A>7.5.52	i<A NAME="marker-54610"></A>neg</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7825"></A>Negate int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7826"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18658"></A><I CLASS="Variable">ineg</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7828"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7829"></A>ineg = 76 (0x4c)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7830"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7831"></A>..., value.word1, value.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7832"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7833"></A>The value must be of type int. It is popped from the operand stack. The int result is the arithmetic negation of value, -value. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7834"></A>For int values, negation is the same as subtraction from zero. Because the Java Card virtual machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative int results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7835"></A>For all int values x, -x equals (&#126;x) + 1.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7836"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7837"></A>If a virtual machine does not support the int data type, the ineg instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7838"></A>7.5.53	i<A NAME="marker-54611"></A>nstanceof</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7839"></A>Determine if object is of given type
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7840"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18650"></A><I CLASS="Variable">instanceof</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18652"></A><I CLASS="Variable">atype</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18654"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-18656"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7845"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7846"></A>instanceof = 149 (0x95)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7847"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7848"></A>..., objectref -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7849"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7850"></A>The unsigned byte atype is a code that indicates if the type against which the object is being checked is an array type or a class type. It must take one of the following values or zero:
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR"><CAPTION CLASS="TableCaption"><A NAME="pgfId-1004336"> </A> TABLE 7-3 	Array Values </CAPTION>
<THEAD>
<TR>
<TH SCOPE="COL" ROWSPAN="1" COLSPAN="1" BGCOLOR="#CCCCCC">
<P CLASS="TableHead"><A NAME="pgfId-1004384"></A>Array Type
</P>
</TH>
<TH SCOPE="COL" ROWSPAN="1" COLSPAN="1" BGCOLOR="#CCCCCC">
<P CLASS="TableHead"><A NAME="pgfId-1004386"></A>atype
</P>
</TH>
</TR>
</THEAD>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004364"></A><KBD CLASS="Filename-Command">T_BOOLEAN</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004366"></A><KBD CLASS="Filename-Command">10</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004368"></A><KBD CLASS="Filename-Command">T_BYTE</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004370"></A><KBD CLASS="Filename-Command">11</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004372"></A><KBD CLASS="Filename-Command">T_SHORT</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004374"></A><KBD CLASS="Filename-Command">12</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004376"></A><KBD CLASS="Filename-Command">T_INT</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004378"></A><KBD CLASS="Filename-Command">13</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004380"></A><KBD CLASS="Filename-Command">T_REFERENCE</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004382"></A><KBD CLASS="Filename-Command">14</KBD>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7876"></A>If the value of atype is 10, 11, 12, or 13, the values of the indexbyte1 and indexbyte2 must be zero, and the value of atype indicates the array type against which to check the object. Otherwise the unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The item at that index in the constant pool must be of type CONSTANT_Classref (<A HREF="JCVM06cap.html#39801" CLASS="XRef">Section 6.7.1, CONSTANT_Classref</A>), a reference to a class or interface type. The reference is resolved. If the value of atype is 14, the object is checked against an array type that is an array of object references of the type of the resolved class. If the value of atype is zero, the object is checked against a class or interface type that is the resolved class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7877"></A>The objectref must be of type reference. It is popped from the operand stack. If objectref is not null and is an instance of the resolved class, array or interface, the instanceof instruction pushes a short result of 1 on the operand stack. Otherwise it pushes a short result of 0.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-48316"></A>The following rules are used to determine whether an objectref that is not null is an instance of the resolved type: if S is the class of the object referred to by objectref and T is the resolved class, array or interface type, instanceof determines whether objectref is an instance of T as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48317"></A>If S is a class type, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48318"></A>If T is a class type, then S must be the same class as T, or S must be a subclass of T;
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-48290"></A>If T is an interface type, then S must implement interface T.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48291"></A>If S is an interface type<A NAME="fnote8"></A><A HREF="#pgfId-53469"  CLASS="footnote"><SUP>[8]</SUP></A>, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48292"></A>If T is a class type, then T must be Object (<A HREF="JCVM02lang.html#Classes" CLASS="XRef">Section 2.2.2.4, Classes</A>);
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-52955"></A>If T is an interface type, T must be the same interface as S or a superinterface of S.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<LI CLASS="Bullet1"><A NAME="pgfId-48441"></A>If S is an array type, namely the type SC[], that is, an array of components of type SC, then:
</LI>
<P CLASS="Linebreak">
</P>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48445"></A>If T is a class type, then T must be Object.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet2"><A NAME="pgfId-48446"></A>If T is an array type, namely the type TC[], an array of components of type TC, then one of the following must be true:
</LI>
<P CLASS="Linebreak">
</P>
</UL>
</UL>
<P CLASS="ParaIndent2"><A NAME="pgfId-48447"></A>TC and SC are the same primitive type (<A HREF="JCVM03structVM.html#91374" CLASS="XRef">Section 3.1, Data Types and Values</A>).
</P>
<P CLASS="ParaIndent2"><A NAME="pgfId-48448"></A>TC and SC are reference types<A NAME="fnote9"></A><A HREF="#pgfId-53460"  CLASS="footnote"><SUP>[9]</SUP></A> (<A HREF="JCVM03structVM.html#91374" CLASS="XRef">Section 3.1, Data Types and Values</A>) with type SC assignable to TC, by these rules.
</P>
<UL>
<UL>
<LI CLASS="Bullet2"><A NAME="pgfId-48449"></A>If T is an interface type, T must be one of the interfaces implemented by arrays.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-7888"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7889"></A>The instanceof instruction is fundamentally very similar to the checkcast instruction. It differs in its treatment of null, its behavior when its test fails (checkcast throws an exception, instanceof pushes a result code), and its effect on the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26750"></A>In some circumstances, the instanceof instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7890"></A>If a virtual machine does not support the int data type, the value of atype may not be 13 (array type = T_INT).
</P><H3 CLASS="Head2"><A NAME="pgfId-7891"></A>7.5.54	i<A NAME="marker-54612"></A>nvokeinterface</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7892"></A>Invoke interface method
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7893"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19094"></A><I CLASS="Variable">invokeinterface</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19096"></A><I CLASS="Variable">nargs</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19098"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19100"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19102"></A><I CLASS="Variable">method</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7899"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7900"></A>invokeinterface = 142 (0x8e)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7901"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7902"></A>..., objectref, [arg1, [arg2 ...]] -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7903"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7904"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The constant pool item at that index must be of type CONSTANT_Classref (<A HREF="JCVM06cap.html#39801" CLASS="XRef">Section 6.7.1, CONSTANT_Classref</A>), a reference to an interface class. The specified interface is resolved. 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54321"></A>The nargs operand is an unsigned byte that must not be zero. 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54328"></A>The method operand is an unsigned byte that is the interface method token for the method to be invoked. The interface method must not be &lt;init&gt; or an instance initialization method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54319"></A>The objectref must be of type reference and must be followed on the operand stack by nargs - 1 words of arguments. The number of words of arguments and the type and order of the values they represent must be consistent with those of the selected interface method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26073"></A>The interface table of the class of the type of objectref is determined. If objectref is an array type, then the interface table of class Object (<A HREF="JCVM02lang.html#Classes" CLASS="XRef">Section 2.2.2.4, Classes</A>) is used. The interface table is searched for the resolved interface. The result of the search is a table that is used to map the method token to a index.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26074"></A>The index is an unsigned byte that is used as an index into the method table of the class of the type of objectref. If the objectref is an array type, then the method table of class Object is used. The table entry at that index includes a direct reference to the method's code and modifier information.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7909"></A>The nargs - 1 words of arguments and objectref are popped from the operand stack. A new stack frame is created for the method being invoked, and objectref and the arguments are made the values of its first nargs words of local variables, with objectref in local variable 0, arg1 in local variable 1, and so on. The new stack frame is then made current, and the Java Card virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7910"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7911"></A>If objectref is null, the invokeinterface instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26760"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26772"></A>In some circumstances, the invokeinterface instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>. If the current context is not the object's context and the Java Card RE permits invocation of the method, the invokeinterface instruction will cause a context switch (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) to the object's context before invoking the method, and will cause a return context switch to the previous context when the invoked method returns.
</P><H3 CLASS="Head2"><A NAME="pgfId-26773"></A>7.5.55	<A NAME="marker-54613"></A>invokespecial</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7913"></A>Invoke instance method; special handling for superclass, private, and instance initialization method invocations
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7914"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19105"></A><I CLASS="Variable">invokespecial</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19107"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19109"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7918"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7919"></A>invokespecial = 140 (0x8c)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7920"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7921"></A>..., objectref, [arg1, [arg2 ...]] -&gt; 
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7922"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54133"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. If the invoked method is a private instance method or an instance initialization method, the constant pool item at index must be of type CONSTANT_StaticMethodref (<A HREF="JCVM06cap.html#21307" CLASS="XRef">Section 6.7.3, CONSTANT_StaticFieldref and CONSTANT_StaticMethodref</A>), a reference to a statically linked instance method. If the invoked method is a superclass method, the constant pool item at index must be of type CONSTANT_SuperMethodref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to an instance method of a specified class. The reference is resolved. The resolved method must not be &lt;clinit&gt;, a class or interface initialization method. If the method is &lt;init&gt;, an instance initialization method, then the method must only be invoked once on an uninitialized object, and before the first backward branch following the execution of the new instruction that allocated the object. Finally, if the resolved method is protected, and it is a member of a superclass of the current class, and the method is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7924"></A>The resolved method includes the code for the method, an unsigned byte nargs that must not be zero, and the method's modifier information.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7925"></A>The objectref must be of type reference, and must be followed on the operand stack by nargs - 1 words of arguments, where the number of words of arguments and the type and order of the values they represent must be consistent with those of the selected instance method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1002685"></A>The nargs - 1 words of arguments and objectref are popped from the operand stack. A new stack frame is created for the method being invoked, and objectref and the arguments are made the values of its first nargs words of local variables, with objectref in local variable 0, arg1 in local variable 1, and so on. The new stack frame is then made current, and the Java Card virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7927"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7928"></A>If objectref is null, the invokespecial instruction throws a NullPointerException.
</P><H3 CLASS="Head2"><A NAME="pgfId-7929"></A>7.5.56	<A NAME="marker-54614"></A>invokestatic</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7930"></A>Invoke a class (static) method
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7931"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19112"></A><I CLASS="Variable">invokestatic</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19114"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19116"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7935"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7936"></A>invokestatic = 141 (0x8d)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7937"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7938"></A>..., [arg1, [arg2 ...]] -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7939"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53881"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The constant pool item at that index must be of type CONSTANT_StaticMethodref (<A HREF="JCVM06cap.html#21307" CLASS="XRef">Section 6.7.3, CONSTANT_StaticFieldref and CONSTANT_StaticMethodref</A>), a reference to a static method. The method must not be &lt;init&gt;, an instance initialization method, or &lt;clinit&gt;, a class or interface initialization method. It must be static, and therefore cannot be abstract.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53888"></A>The resolved method includes the code for the method, an unsigned byte nargs that may be zero, and the method's modifier information.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7942"></A>The operand stack must contain nargs words of arguments, where the number of words of arguments and the type and order of the values they represent must be consistent with those of the resolved method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7943"></A>The nargs words of arguments are popped from the operand stack. A new stack frame is created for the method being invoked, and the words of arguments are made the values of its first nargs words of local variables, with arg1 in local variable 0, arg2 in local variable 1, and so on. The new stack frame is then made current, and the Java Card virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.
</P><H3 CLASS="Head2"><A NAME="pgfId-7944"></A>7.5.57	i<A NAME="marker-54615"></A>nvokevirtual</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7945"></A>Invoke instance method; dispatch based on class
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7946"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19119"></A><I CLASS="Variable">invokevirtual</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19121"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19123"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7950"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7951"></A>invokevirtual = 139 (0x8b)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7952"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7953"></A>..., objectref, [arg1, [arg2 ...]] -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7954"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54143"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The constant pool item at that index must be of type CONSTANT_VirtualMethodref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to a class and a virtual method token. The specified method is resolved. The method must not be &lt;init&gt;, an instance initialization method, or &lt;clinit&gt;, a class or interface initialization method. Finally, if the resolved method is protected, and it is a member of a superclass of the current class, and the method is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7955"></A>The resolved method reference includes an unsigned index into the method table of the resolved class and an unsigned byte nargs that must not be zero.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7957"></A>The objectref must be of type reference. The index is an unsigned byte that is used as an index into the method table of the class of the type of objectref. If the objectref is an array type, then the method table of class Object (<A HREF="JCVM02lang.html#Classes" CLASS="XRef">Section 2.2.2.4, Classes</A>) is used. The table entry at that index includes a direct reference to the method's code and modifier information.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7958"></A>The objectref must be followed on the operand stack by nargs - 1 words of arguments, where the number of words of arguments and the type and order of the values they represent must be consistent with those of the selected instance method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7959"></A>The nargs - 1 words of arguments and objectref are popped from the operand stack. A new stack frame is created for the method being invoked, and objectref and the arguments are made the values of its first nargs words of local variables, with objectref in local variable 0, arg1 in local variable 1, and so on. The new stack frame is then made current, and the Java Card virtual machine pc is set to the opcode of the first instruction of the method to be invoked. Execution continues with the first instruction of the method.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7960"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26961"></A>If objectref is null, the invokevirtual instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26969"></A>In some circumstances, the invokevirtual instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>. If the current context is not the object's context and the Java Card RE permits invocation of the method, the invokevirtual instruction will cause a context switch (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) to the object's context before invoking the method, and will cause a return context switch to the previous context when the invoked method returns.
</P><H3 CLASS="Head2"><A NAME="pgfId-26964"></A>7.5.58	<A NAME="marker-54616"></A>ior</H3>
<P CLASS="Paragraph"><A NAME="pgfId-26965"></A>Boolean OR int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7964"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19126"></A><I CLASS="Variable">ior</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7966"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7967"></A>ior = 86 (0x56)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7968"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7969"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7970"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7971"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by taking the bitwise inclusive OR of value1 and value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7972"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7973"></A>If a virtual machine does not support the int data type, the ior instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7974"></A>7.5.59	i<A NAME="marker-54617"></A>rem</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7975"></A>Remainder int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7976"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-23455"></A><I CLASS="Variable">irem</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7978"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7979"></A>irem = 74 (0x4a)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7980"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7981"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7982"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7983"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is the value of the Java expression value1 - (value1 / value2) * value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7984"></A>The result of the irem instruction is such that (a/b)*b + (a%b) is equal to a. This identity holds even in the special case that the dividend is the negative int of largest possible magnitude for its type and the divisor is -1 (the remainder is 0). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7985"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7986"></A>If the value of the divisor for a short remainder operator is 0, irem throws an ArithmeticException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7987"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7988"></A>If a virtual machine does not support the int data type, the irem instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-7989"></A>7.5.60	<A NAME="marker-54618"></A>ireturn</H3>
<P CLASS="Paragraph"><A NAME="pgfId-7990"></A>Return int from method
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7991"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-19129"></A><I CLASS="Variable">ireturn</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-7993"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7994"></A>ireturn = 121 (0x79)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7995"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7996"></A>..., value.word1, value.word2 -&gt;
<BR>[empty]
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7997"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7998"></A>The value must be of type int. It is popped from the operand stack of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>) and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-7999"></A>The virtual machine then reinstates the frame of the invoker and returns control to the invoker.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8000"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8001"></A>If a virtual machine does not support the int data type, the ireturn instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8002"></A>7.5.61	<A NAME="marker-54619"></A>ishl</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8003"></A>Shift left int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8004"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21064"></A><I CLASS="Variable">ishl</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8006"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8007"></A>ishl = 78 (0x4e)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8008"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8009"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8010"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8011"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by shifting value1 left by s bit positions, where s is the value of the low five bits of value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8012"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8013"></A>This is equivalent (even if overflow occurs) to multiplication by 2 to the power s. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8014"></A>If a virtual machine does not support the int data type, the ishl instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8015"></A>7.5.62	<A NAME="marker-54620"></A>ishr</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8016"></A>Arithmetic shift right int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8017"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21067"></A><I CLASS="Variable">ishr</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8019"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8020"></A>ishr = 80 (0x50)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8021"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8022"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8023"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8024"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by shifting value1 right by s bit positions, with sign extension, where s is the value of the low five bits of value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8025"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8026"></A>The resulting value is &Icirc;(value1) / 2s&#176;, where s is value2 &amp; 0x1f. For nonnegative value1, this is equivalent (even if overflow occurs) to truncating int division by 2 to the power s. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8027"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8028"></A>If a virtual machine does not support the int data type, the ishr instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8029"></A>7.5.63	<A NAME="marker-54621"></A>istore</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8030"></A>Store int into local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8031"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21070"></A><I CLASS="Variable">istore</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21072"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8034"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8035"></A>istore = 42 (0x2a)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8036"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8037"></A>..., value.word1, value.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8038"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8039"></A>The index is an unsigned byte. Both index and index + 1 must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The value on top of the operand stack must be of type int. It is popped from the operand stack, and the local variables at index and index + 1 are set to value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8040"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8041"></A>If a virtual machine does not support the int data type, the istore instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8042"></A>7.5.64	<A NAME="marker-54622"></A>istore_&lt;n&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8043"></A>Store int into local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8044"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21075"></A><I CLASS="Variable">istore_&lt;n&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8046"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8047"></A>istore_0 = 51 (0x33)
<BR>istore_1 = 52 (0x34)
<BR>istore_2 = 53 (0x35)
<BR>istore_3 = 54 (0x36)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8048"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8049"></A>..., value.word1, value.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8050"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8051"></A>Both &lt;n&gt; and &lt;n&gt; + 1 must be a valid indices into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The value on top of the operand stack must be of type int. It is popped from the operand stack, and the local variables at index and index + 1 are set to value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8052"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8053"></A>If a virtual machine does not support the int data type, the istore_&lt;n&gt; instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8054"></A>7.5.65	<A NAME="marker-54623"></A>isub</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8055"></A>Subtract int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8056"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21078"></A><I CLASS="Variable">isub</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8058"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8059"></A>isub = 68 (0x44)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8060"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8061"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8062"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8063"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. The int result is value1 - value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8064"></A>For int subtraction, a - b produces the same result as a + (-b). For int values, subtraction from zeros is the same as negation.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8065"></A>Despite the fact that overflow or underflow may occur, in which case the result may have a different sign than the true mathematical result, execution of an isub instruction never throws a runtime exception.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8066"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8067"></A>If a virtual machine does not support the int data type, the isub instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8068"></A>7.5.66	<A NAME="marker-54624"></A>itableswitch</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8069"></A>Access jump table by int index and jump
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8070"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21081"></A><I CLASS="Variable">itableswitch</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21083"></A><I CLASS="Variable">defaultbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21085"></A><I CLASS="Variable">defaultbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21087"></A><I CLASS="Variable">lowbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21089"></A><I CLASS="Variable">lowbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21091"></A><I CLASS="Variable">lowbyte3</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21093"></A><I CLASS="Variable">lowbyte4</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21095"></A><I CLASS="Variable">highbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21097"></A><I CLASS="Variable">highbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21099"></A><I CLASS="Variable">highbyte3</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21101"></A><I CLASS="Variable">highbyte4</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21103"></A><I CLASS="Variable">jump offsets</I>...
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8083"></A>Offset Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21110"></A><I CLASS="Variable">offsetbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21112"></A><I CLASS="Variable">offsetbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8086"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8087"></A>itableswitch = 116 (0x74)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8088"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8089"></A>..., index -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8090"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8091"></A>An itableswitch instruction is a variable-length instruction. Immediately after the itableswitch opcode follow a signed 16-bit value default, a signed 32-bit value low, a signed 32-bit value high, and then high - low + 1 further signed 16-bit offsets. The value low must be less than or equal to high. The high - low + 1 signed 16-bit offsets are treated as a 0-based jump table. Each of the signed 16-bit values is constructed from two unsigned bytes as (byte1 &lt;&lt; 8) | byte2. Each of the signed 32-bit values is constructed from four unsigned bytes as (byte1 &lt;&lt; 24) | (byte2 &lt;&lt; 16) | (byte3 &lt;&lt; 8) | byte4.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8092"></A>The index must be of type int and is popped from the stack. If index is less than low or index is greater than high, then a target address is calculated by adding default to the address of the opcode of this itableswitch instruction. Otherwise, the offset at position index - low of the jump table is extracted. The target address is calculated by adding that offset to the address of the opcode of this itableswitch instruction. Execution then continues at the target address.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8093"></A>The target addresses that can be calculated from each jump table offset, as well as the one calculated from default, must be the address of an opcode of an instruction within the method that contains this itableswitch instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8094"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8095"></A>If a virtual machine does not support the int data type, the itableswitch instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8096"></A>7.5.67	<A NAME="marker-54625"></A>iushr</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8097"></A>Logical shift right int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8098"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21116"></A><I CLASS="Variable">iushr</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8100"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8101"></A>iushr = 82 (0x52)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8102"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8103"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8104"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8105"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by shifting the result right by s bit positions, with zero extension, where s is the value of the low five bits of value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8106"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8107"></A>If value1 is positive and s is value2 &amp; 0x1f, the result is the same as that of value1 &gt;&gt; s; if value1 is negative, the result is equal to the value of the expression (value1 &gt;&gt; s) + (2 &lt;&lt; &#126;s). The addition of the (2 &lt;&lt; &#126;s) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8108"></A>If a virtual machine does not support the int data type, the iushr instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8109"></A>7.5.68	<A NAME="marker-54626"></A>ixor</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8110"></A>Boolean XOR int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8111"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21119"></A><I CLASS="Variable">ixor</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8113"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8114"></A>ixor = 88 (0x58)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8115"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8116"></A>..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8117"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8118"></A>Both value1 and value2 must be of type int. The values are popped from the operand stack. An int result is calculated by taking the bitwise exclusive OR of value1 and value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8119"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8120"></A>If a virtual machine does not support the int data type, the ixor instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8121"></A>7.5.69	j<A NAME="marker-54627"></A>sr</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8122"></A>Jump subroutine
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8123"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21122"></A><I CLASS="Variable">jsr</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21124"></A><I CLASS="Variable">branchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21126"></A><I CLASS="Variable">branchbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8127"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8128"></A>jsr = 113 (0x71)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8129"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8130"></A>... -&gt;
<BR>..., address
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8131"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8132"></A>The address of the opcode of the instruction immediately following this jsr instruction is pushed onto the operand stack as a value of type returnAddress. The unsigned branchbyte1 and branchbyte2 are used to construct a signed 16-bit offset, where the offset is (branchbyte1 &lt;&lt; 8) | branchbyte2. Execution proceeds at that offset from the address of this jsr instruction. The target address must be that of an opcode of an instruction within the method that contains this jsr instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8133"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8134"></A>The jsr instruction is used with the ret instruction in the implementation of the finally clause of the Java language. Note that jsr pushes the address onto the stack and ret gets it out of a local variable. This asymmetry is intentional.
</P><H3 CLASS="Head2"><A NAME="pgfId-8135"></A>7.5.70	<A NAME="marker-54628"></A>new</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8136"></A>Create new object
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8137"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21129"></A><I CLASS="Variable">new</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21131"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21133"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8141"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8142"></A>new = 143 (0x8f)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8143"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8144"></A>... -&gt;
<BR>..., objectref
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8145"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8146"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The item at that index in the constant pool must be of type CONSTANT_Classref (<A HREF="JCVM06cap.html#39801" CLASS="XRef">Section 6.7.1, CONSTANT_Classref</A>), a reference to a class or interface type. The reference is resolved and must result in a class type (it must not result in an interface type). Memory for a new instance of that class is allocated from the heap, and the instance variables of the new object are initialized to their default initial values. The objectref, a reference to the instance, is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8147"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8148"></A>The new instruction does not completely create a new instance; instance creation is not completed until an instance initialization method has been invoked on the uninitialized instance.
</P><H3 CLASS="Head2"><A NAME="pgfId-8149"></A>7.5.71	<A NAME="marker-54629"></A>newarray</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8150"></A>Create new array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8151"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21136"></A><I CLASS="Variable">newarray</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21138"></A><I CLASS="Variable">atype</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8154"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8155"></A>newarray = 144 (0x90)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8156"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8157"></A>..., count -&gt;
<BR>..., arrayref
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8158"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8159"></A>The count must be of type short. It is popped off the operand stack. The count represents the number of elements in the array to be created.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1004986"></A>The unsigned byte atype is a code that indicates the type of array to create. It must take one of the following values: 
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR"><CAPTION CLASS="TableCaption"><A NAME="pgfId-1004989"> </A> TABLE 7-4 	Array Values </CAPTION>
<THEAD>
<TR>
<TH SCOPE="COL" ROWSPAN="1" COLSPAN="1" BGCOLOR="#CCCCCC">
<P CLASS="TableHead"><A NAME="pgfId-1004993"></A>Array Type
</P>
</TH>
<TH SCOPE="COL" ROWSPAN="1" COLSPAN="1" BGCOLOR="#CCCCCC">
<P CLASS="TableHead"><A NAME="pgfId-1004995"></A><I CLASS="Variable">atype</I>
</P>
</TH>
</TR>
</THEAD>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004997"></A><KBD CLASS="Filename-Command">T_BOOLEAN</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1004999"></A><KBD CLASS="Filename-Command">10</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1005001"></A><KBD CLASS="Filename-Command">T_BYTE</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1005003"></A><KBD CLASS="Filename-Command">11</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1005005"></A><KBD CLASS="Filename-Command">T_SHORT</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1005007"></A><KBD CLASS="Filename-Command">12</KBD>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1005009"></A><KBD CLASS="Filename-Command">T_INT</KBD>
</P>
</TD>
<TD ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-1005011"></A><KBD CLASS="Filename-Command">13</KBD>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-1005012"></A>A new array whose components are of type atype, of length count, is allocated from the heap. A reference arrayref to this new array object is pushed onto the operand stack. All of the elements of the new array are initialized to the default initial value for its type.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8183"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8184"></A>If count is less than zero, the newarray instruction throws a NegativeArraySizeException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8185"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8186"></A>If a virtual machine does not support the int data type, the value of atype may not be 13 (array type = T_INT).
</P><H3 CLASS="Head2"><A NAME="pgfId-8187"></A>7.5.72	<A NAME="marker-54630"></A>nop</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8188"></A>Do nothing
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8189"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21141"></A><I CLASS="Variable">nop</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8191"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8192"></A>nop = 0 (0x0)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8193"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8194"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8195"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8196"></A>Do nothing.
</P><H3 CLASS="Head2"><A NAME="pgfId-8197"></A>7.5.73	<A NAME="marker-54631"></A>pop</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8198"></A>Pop top operand stack word
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8199"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21147"></A><I CLASS="Variable">pop</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8201"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8202"></A>pop = 59 (0x3b)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8203"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8204"></A>..., word -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8205"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8206"></A>The top word is popped from the operand stack. The pop instruction must not be used unless the word contains a 16-bit data type.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8207"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8208"></A>The pop instruction operates on an untyped word, ignoring the type of data it contains.
</P><H3 CLASS="Head2"><A NAME="pgfId-8209"></A>7.5.74	<A NAME="marker-54632"></A>pop2</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8210"></A>Pop top two operand stack words
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8211"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21150"></A><I CLASS="Variable">pop2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8213"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8214"></A>pop2 = 60 (0x3c)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8215"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8216"></A>..., word2, word1 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8217"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8218"></A>The top two words are popped from the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8219"></A>The pop2 instruction must not be used unless each of word1 and word2 is a word that contains a 16-bit data type or both together are the two words of a single 32-bit datum.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8220"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8221"></A>Except for restrictions preserving the integrity of 32-bit data types, the pop2 instruction operates on an untyped word, ignoring the type of data it contains.
</P><H3 CLASS="Head2"><A NAME="pgfId-8222"></A>7.5.75	<A NAME="marker-54633"></A>putfield_&lt;t&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8223"></A>Set field in object
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8224"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21153"></A><I CLASS="Variable">putfield_&lt;t&gt;</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21155"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8227"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8228"></A>putfield_a = 135 (0x87)
<BR>putfield_b = 136 (0x88)
<BR>putfield_s = 137 (0x89)
<BR>putfield_i = 138 (0x8a)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8229"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8230"></A>..., objectref, value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8231"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8232"></A>..., objectref, value.word1, value.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8233"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53901"></A>The unsigned index is used as an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The constant pool item at the index must be of type CONSTANT_InstanceFieldref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to a class and a field token.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54028"></A>The class of objectref must not be an array. If the field is protected, and it is a member of a superclass of the current class, and the field is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class. If the field is final, it must be declared in the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8235"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-8236"></A>a  field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8237"></A>b  field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8238"></A>s  field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-53524"></A>i  field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-54329"></A>value must be of a type that is assignment compatible with the field descriptor (t) type.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53525"></A>The width of a field in a class instance is determined by the field type specified in the instruction. The item is resolved, determining the field offset<A NAME="fnote10"></A><A HREF="#pgfId-53528"  CLASS="footnote"><SUP>[10]</SUP></A>. The objectref, which must be of type reference, and the value are popped from the operand stack. If the field is of type byte or type boolean, the value is truncated to a byte. The field at the offset from the start of the object referenced by objectref is set to the value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8241"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8242"></A>If objectref is null, the putfield_&lt;t&gt; instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26839"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26857"></A>In some circumstances, the putfield_&lt;t&gt; instruction may throw a SecurityException if the current context <A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26858"></A>If a virtual machine does not support the int data type, the putfield_i instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8245"></A>7.5.76	<A NAME="marker-54634"></A>putfield_&lt;t&gt;_this</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8246"></A>Set field in current object
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8247"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21158"></A><I CLASS="Variable">putfield_&lt;t&gt;_this</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21160"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8250"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8251"></A>putfield_a_this = 181 (0xb5)
<BR>putfield_b_this = 182 (0xb6)
<BR>putfield_s_this = 183 (0xb7)
<BR>putfield_i_this = 184 (0xb8)
<BR>
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8252"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8253"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8254"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8255"></A>..., value.word1, value.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8256"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53916"></A>The currently executing method must be an instance method that was invoked using the invokevirtual, invokeinterface or invokespecial instruction. The local variable at index 0 must contain a reference objectref to the currently executing method's this parameter. The unsigned index is used as an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The constant pool item at the index must be of type CONSTANT_InstanceFieldref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to a class and a field token.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54033"></A>The class of objectref must not be an array. If the field is protected, and it is a member of a superclass of the current class, and the field is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class. If the field is final, it must be declared in the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8258"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-8259"></A>a  field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8260"></A>b  field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1002837"></A>s  field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-1002838"></A>i  field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-1002839"></A>value must be of a type that is assignment compatible with the field descriptor (t) type.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53533"></A>The width of a field in a class instance is determined by the field type specified in the instruction. The item is resolved, determining the field offset<A NAME="fnote11"></A><A HREF="#pgfId-53156"  CLASS="footnote"><SUP>[11]</SUP></A>. The value is popped from the operand stack. If the field is of type byte or type boolean, the value is truncated to a byte. The field at the offset from the start of the object referenced by objectref is set to the value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8264"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8265"></A>If objectref is null, the putfield_&lt;t&gt;_this instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26862"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26863"></A>In some circumstances, the putfield_&lt;t&gt;_this instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8267"></A>If a virtual machine does not support the int data type, the putfield_i_this instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8268"></A>7.5.77	<A NAME="marker-54635"></A>putfield_&lt;t&gt;_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8269"></A>Set field in object (wide index)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8270"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21163"></A><I CLASS="Variable">putfield&lt;t&gt;_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21165"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21167"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8274"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8275"></A>putfield_a_w = 177 (0xb1)
<BR>putfield_b_w = 178 (0xb2)
<BR>putfield_s_w = 179 (0xb3)
<BR>putfield_i_w = 180 (0xb4)
<BR>
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8276"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8277"></A>..., objectref, value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8278"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8279"></A>..., objectref, value.word1, value.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8280"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53940"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The constant pool item at the index must be of type CONSTANT_InstanceFieldref (<A HREF="JCVM06cap.html#15653" CLASS="XRef">Section 6.7.2, CONSTANT_InstanceFieldref, CONSTANT_VirtualMethodref, and CONSTANT_SuperMethodref</A>), a reference to a class and a field token.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54038"></A>The class of objectref must not be an array. If the field is protected, and it is a member of a superclass of the current class, and the field is not declared in the same package as the current class, then the class of objectref must be either the current class or a subclass of the current class. If the field is final, it must be declared in the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8282"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-8283"></A>a  field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8284"></A>b  field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8285"></A>s  field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8286"></A>i  field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-54351"></A>value must be of a type that is assignment compatible with the field descriptor (t) type.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8287"></A>The width of a field in a class instance is determined by the field type specified in the instruction. The item is resolved, determining the field offset<A NAME="fnote12"></A><A HREF="#pgfId-53163"  CLASS="footnote"><SUP>[12]</SUP></A>. The objectref, which must be of type reference, and the value are popped from the operand stack. If the field is of type byte or type boolean, the value is truncated to a byte. The field at the offset from the start of the object referenced by objectref is set to the value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8288"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8289"></A>If objectref is null, the putfield_&lt;t&gt;_w instruction throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26871"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26872"></A>In some circumstances, the putfield_&lt;t&gt;_w instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object referenced by objectref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8291"></A>If a virtual machine does not support the int data type, the putfield_i_w instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8292"></A>7.5.78	<A NAME="marker-54636"></A>putstatic_&lt;t&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8293"></A>Set static field in class
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8294"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21170"></A><I CLASS="Variable">putstatic_&lt;t&gt;</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21172"></A><I CLASS="Variable">indexbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21174"></A><I CLASS="Variable">indexbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8298"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8299"></A>putstatic_a = 127 (0x7f)
<BR>putstatic_b = 128 (0x80)
<BR>putstatic_s = 129 (0x81)
<BR>putstatic_i = 130 (0x82)
<BR>
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8300"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8301"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8302"></A>OR
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8303"></A>..., value.word1, value.word2 -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8304"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8305"></A>The unsigned indexbyte1 and indexbyte2 are used to construct an index into the constant pool of the current package (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>), where the value of the index is (indexbyte1 &lt;&lt; 8) | indexbyte2. The constant pool item at the index must be of type CONSTANT_StaticFieldref (<A HREF="JCVM06cap.html#21307" CLASS="XRef">Section 6.7.3, CONSTANT_StaticFieldref and CONSTANT_StaticMethodref</A>), a reference to a static field. If the field is final, it must be declared in the current class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8306"></A>The item must resolve to a field with a type that matches t, as follows:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-8307"></A>a  field must be of type reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8308"></A>b  field must be of type byte or type boolean
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8309"></A>s  field must be of type short
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-8310"></A>i  field must be of type int
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-54358"></A>value must be of a type that is assignment compatible with the field descriptor (t) type.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8311"></A>The width of a class field is determined by the field type specified in the instruction. The item is resolved, determining the class field. The value is popped from the operand stack. If the field is of type byte or type boolean, the value is truncated to a byte. The field is set to the value.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8312"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-27121"></A>In some circumstances, the putstatic_a instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the object being stored in the field. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-27135"></A>If a virtual machine does not support the int data type, the putstatic_i instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8314"></A>7.5.79	<A NAME="marker-54637"></A>ret</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8315"></A>Return from subroutine
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8316"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21177"></A><I CLASS="Variable">ret</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21179"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8319"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8320"></A>ret = 114 (0x72)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8321"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8322"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8323"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8324"></A>The index is an unsigned byte that must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variable at index must contain a value of type returnAddress. The contents of the local variable are written into the Java Card virtual machine's pc register, and execution continues there.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8325"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8326"></A>The ret instruction is used with the jsr instruction in the implementation of the finally keyword of the Java language. Note that jsr pushes the address onto the stack and ret gets it out of a local variable. This asymmetry is intentional.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8327"></A>The ret instruction should not be confused with the return instruction. A return instruction returns control from a Java method to its invoker, without passing any value back to the invoker.
</P><H3 CLASS="Head2"><A NAME="pgfId-8328"></A>7.5.80	<A NAME="marker-54638"></A>return</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8329"></A>Return void from method
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8330"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21182"></A><I CLASS="Variable">return</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8332"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8333"></A>return = 122 (0x7a)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8334"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8335"></A>... -&gt;
<BR>[empty]
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8336"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8337"></A>Any values on the operand stack of the current method are discarded. The virtual machine then reinstates the frame of the invoker and returns control to the invoker.
</P><H3 CLASS="Head2"><A NAME="pgfId-8338"></A>7.5.81	<A NAME="marker-54639"></A>s2b</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8339"></A>Convert short to byte
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8340"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21185"></A><I CLASS="Variable">s2b</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8342"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8343"></A>s2b = 91 (0x5b)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8344"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8345"></A>..., value -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8346"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8347"></A>The value on top of the operand stack must be of type short. It is popped from the top of the operand stack, truncated to a byte result, then sign-extended to a short result. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8348"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8349"></A>The s2b instruction performs a narrowing primitive conversion. It may lose information about the overall magnitude of value. The result may also not have the same sign as value.
</P><H3 CLASS="Head2"><A NAME="pgfId-8350"></A>7.5.82	s<A NAME="marker-54640"></A>2i</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8351"></A>Convert short to int
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8352"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21188"></A><I CLASS="Variable">s2i</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8354"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8355"></A>s2i = 92 (0x5c)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8356"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8357"></A>..., value -&gt;
<BR>..., result.word1, result.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8358"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8359"></A>The value on top of the operand stack must be of type short. It is popped from the operand stack and sign-extended to an int result. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8360"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8361"></A>The s2i instruction performs a widening primitive conversion. Because all values of type short are exactly representable by type int, the conversion is exact.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8362"></A>If a virtual machine does not support the int data type, the s2i instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8363"></A>7.5.83	<A NAME="marker-54641"></A>sadd</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8364"></A>Add short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8365"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21191"></A><I CLASS="Variable">sadd</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8367"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8368"></A>sadd = 65 (0x41)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8369"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8370"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8371"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8372"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. The short result is value1 + value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8373"></A>If a sadd instruction overflows, then the result is the low-order bits of the true mathematical result in a sufficiently wide two's-complement format. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical sum of the two values.
</P><H3 CLASS="Head2"><A NAME="pgfId-8374"></A>7.5.84	<A NAME="marker-54642"></A>saload</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8375"></A>Load short from array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8376"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21194"></A><I CLASS="Variable">saload</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8378"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8379"></A>saload = 38 (0x46)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8380"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8381"></A>..., arrayref, index -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8382"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8383"></A>The arrayref must be of type reference and must refer to an array whose components are of type short. The index must be of type short. Both arrayref and index are popped from the operand stack. The short value in the component of the array at index is retrieved and pushed onto the top of the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8384"></A>Runtime Exceptions
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8385"></A>If arrayref is null, saload throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8386"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the saload instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26880"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26881"></A>In some circumstances, the saload instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-8387"></A>7.5.85	<A NAME="marker-54643"></A>sand</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8388"></A>Boolean AND short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8389"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21197"></A><I CLASS="Variable">sand</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8391"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8392"></A>sand = 83 (0x53)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8393"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8394"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8395"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8396"></A>Both value1 and value2 are popped from the operand stack. A short result is calculated by taking the bitwise AND (conjunction) of value1 and value2. The result is pushed onto the operand stack.
</P><H3 CLASS="Head2"><A NAME="pgfId-8397"></A>7.5.86	<A NAME="marker-54644"></A>sastore</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8398"></A>Store into short array
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8399"></A>Format 
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21200"></A><I CLASS="Variable">sastore</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8401"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8402"></A>sastore = 57 (0x39)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8403"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8404"></A>..., arrayref, index, value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8405"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8406"></A>The arrayref must be of type reference and must refer to an array whose components are of type short. The index and value must both be of type short. The arrayref, index and value are popped from the operand stack. The short value is stored as the component of the array indexed by index.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8407"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8408"></A>If arrayref is null, sastore throws a NullPointerException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8409"></A>Otherwise, if index is not within the bounds of the array referenced by arrayref, the sastore instruction throws an ArrayIndexOutOfBoundsException.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-26889"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54885"></A>In some circumstances, the sastore instruction may throw a SecurityException if the current context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) is not the owning context (<A HREF="JCVM03structVM.html#33311" CLASS="XRef">Section 3.4, Contexts</A>) of the array referenced by arrayref. The exact circumstances when the exception will be thrown are specified in Chapter 6 of the <EM CLASS="Emphasis">Runtime Environment Specification, Java Card Platform, Version 2.2.2</EM>.
</P><H3 CLASS="Head2"><A NAME="pgfId-54896"></A>7.5.87	<A NAME="marker-54895"></A>sconst_&lt;s&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-54897"></A>Push short constant
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8412"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21203"></A><I CLASS="Variable">sconst_&lt;s&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8414"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8415"></A>sconst_m1 = 2 (0x2)
<BR>sconst_0 = 3 (0x3)
<BR>sconst_1 = 4 (0x4)
<BR>sconst_2 = 5 (0x5)
<BR>sconst_3 = 6 (0x6)
<BR>sconst_4= 7 (0x7)
<BR>sconst_5 = 8 (0x8)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8416"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8417"></A>... -&gt;
<BR>..., &lt;s&gt;
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8418"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8419"></A>Push the short constant &lt;s&gt; (-1, 0, 1, 2, 3, 4, or 5) onto the operand stack.
</P><H3 CLASS="Head2"><A NAME="pgfId-8420"></A>7.5.88	<A NAME="marker-54646"></A>sdiv</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8421"></A>Divide short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8422"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21206"></A><I CLASS="Variable">sdiv</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8424"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8425"></A>sdiv = 71 (0x47)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8426"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8427"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8428"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8429"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. The short result is the value of the Java expression value1 / value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8430"></A>A short division rounds towards 0; that is, the quotient produced for short values in n/d is a short value q whose magnitude is as large as possible while satisfying | d &#183; q | &lt;= | n |. Moreover, q is a positive when | n | &gt;= | d | and n and d have the same sign, but q is negative when | n | &gt;= | d | and n and d have opposite signs.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8431"></A>There is one special case that does not satisfy this rule: if the dividend is the negative integer of the largest possible magnitude for the short type, and the divisor is -1, then overflow occurs, and the result is equal to the dividend. Despite the overflow, no exception is thrown in this case.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8432"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8433"></A>If the value of the divisor in a short division is 0, sdiv throws an ArithmeticException.
</P><H3 CLASS="Head2"><A NAME="pgfId-8434"></A>7.5.89	<A NAME="marker-54647"></A>sinc</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8435"></A>Increment local short variable by constant
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8436"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21209"></A><I CLASS="Variable">sinc</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21211"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21213"></A><I CLASS="Variable">const</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8440"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8441"></A>sinc = 89 (0x59)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8442"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8443"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8444"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8445"></A>The index is an unsigned byte that must be a valid index into the local variable of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The const is an immediate signed byte. The local variable at index must contain a short. The value const is first sign-extended to a short, then the local variable at index is incremented by that amount.
</P><H3 CLASS="Head2"><A NAME="pgfId-8446"></A>7.5.90	<A NAME="marker-54648"></A>sinc_w</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8447"></A>Increment local short variable by constant
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8448"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21216"></A><I CLASS="Variable">sinc_w</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21218"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21220"></A><I CLASS="Variable">byte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21222"></A><I CLASS="Variable">byte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8453"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8454"></A>sinc_w = 150 (0x96)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8455"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8456"></A>No change
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8457"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8458"></A>The index is an unsigned byte that must be a valid index into the local variable of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The immediate unsigned byte1 and byte2 values are assembled into a short const where the value of const is (byte1 &lt;&lt; 8) | byte2. The local variable at index, which must contain a short, is incremented by const.
</P><H3 CLASS="Head2"><A NAME="pgfId-8459"></A>7.5.91	<A NAME="marker-54649"></A>sipush</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8460"></A>Push short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8461"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21225"></A><I CLASS="Variable">sipush</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21227"></A><I CLASS="Variable">byte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21229"></A><I CLASS="Variable">byte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8465"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8466"></A>sipush = 19 (0x13)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8467"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8468"></A>... -&gt;
<BR>..., value1.word1, value1.word2
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8469"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8470"></A>The immediate unsigned byte1 and byte2 values are assembled into a signed short where the value of the short is (byte1 &lt;&lt; 8) | byte2. The intermediate value is then sign-extended to an int, and the resulting value is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8471"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8472"></A>If a virtual machine does not support the int data type, the sipush instruction will not be available.
</P><H3 CLASS="Head2"><A NAME="pgfId-8473"></A>7.5.92	<A NAME="marker-54650"></A>sload</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8474"></A>Load short from local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8475"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21232"></A><I CLASS="Variable">sload</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21234"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8478"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8479"></A>sload = 22 (0x16)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8480"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8481"></A>... -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8482"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8483"></A>The index is an unsigned byte that must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variable at index must contain a short. The value in the local variable at index is pushed onto the operand stack.
</P><H3 CLASS="Head2"><A NAME="pgfId-8484"></A>7.5.93	<A NAME="marker-54651"></A>sload_&lt;n&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8485"></A>Load short from local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8486"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21237"></A><I CLASS="Variable">sload_&lt;n&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8488"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8489"></A>sload_0 = 28 (0x1c)
<BR>sload_1 = 29 (0x1d)
<BR>sload_2 = 30 (0x1e)
<BR>sload_3 = 31 (0x1f)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1002942"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-1002943"></A>... -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8492"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8493"></A>The &lt;n&gt; must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The local variable at &lt;n&gt; must contain a short. The value in the local variable at &lt;n&gt; is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8494"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8495"></A>Each of the sload_&lt;n&gt; instructions is the same as sload with an index of &lt;n&gt;, except that the operand &lt;n&gt; is implicit.
</P><H3 CLASS="Head2"><A NAME="pgfId-8496"></A>7.5.94	<A NAME="marker-54652"></A>slookupswitch</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8497"></A>Access jump table by key match and jump
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8498"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21240"></A><I CLASS="Variable">slookupswitch</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21242"></A><I CLASS="Variable">defaultbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21244"></A><I CLASS="Variable">defaultbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21246"></A><I CLASS="Variable">npairs1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21248"></A><I CLASS="Variable">npairs2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21250"></A><I CLASS="Variable">match-offset pairs</I>...
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8505"></A>Pair Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25942"></A><I CLASS="Variable">matchbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25944"></A><I CLASS="Variable">matchbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25946"></A><I CLASS="Variable">offsetbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-25948"></A><I CLASS="Variable">offsetbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8510"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8511"></A>slookupswitch = 117 (0x75)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8512"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8513"></A>..., key -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8514"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8515"></A>A slookupswitch instruction is a variable-length instruction. Immediately after the slookupswitch opcode follow a signed 16-bit value default, an unsigned 16-bit value npairs, and then npairs pairs. Each pair consists of a short match and a signed 16-bit offset. Each of the signed 16-bit values is constructed from two unsigned bytes as (byte1 &lt;&lt; 8) | byte2.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8516"></A>The table match-offset pairs of the slookupswitch instruction must be sorted in increasing numerical order by match.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8517"></A>The key must be of type short and is popped from the operand stack and compared against the match values. If it is equal to one of them, then a target address is calculated by adding the corresponding offset to the address of the opcode of this slookupswitch instruction. If the key does not match any of the match values, the target address is calculated by adding default to the address of the opcode of this slookupswitch instruction. Execution then continues at the target address.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-51640"></A>The target address that can be calculated from the offset of each match-offset pair, as well as the one calculated from default, must be the address of an opcode of an instruction within the method that contains this slookupswitch instruction.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-51642"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-51653"></A>The match-offset pairs are sorted to support lookup routines that are quicker than linear search.
</P><H3 CLASS="Head2"><A NAME="pgfId-51654"></A>7.5.95	<A NAME="marker-54653"></A>smul</H3>
<P CLASS="Paragraph"><A NAME="pgfId-51655"></A>Multiply short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8523"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21253"></A><I CLASS="Variable">smul</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8525"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8526"></A>smul = 69 (0x45)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8527"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8528"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8529"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8530"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. The short result is value1 * value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8531"></A>If a smul instruction overflows, then the result is the low-order bits of the mathematical product as a short. If overflow occurs, then the sign of the result may not be the same as the sign of the mathematical product of the two values.
</P><H3 CLASS="Head2"><A NAME="pgfId-8532"></A>7.5.96	s<A NAME="marker-54654"></A>neg</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8533"></A>Negate short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8534"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21256"></A><I CLASS="Variable">sneg</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8536"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8537"></A>sneg = 72 (0x4b)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8538"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8539"></A>..., value -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8540"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8541"></A>The value must be of type short. It is popped from the operand stack. The short result is the arithmetic negation of value, -value. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8542"></A>For short values, negation is the same as subtraction from zero. Because the Java Card virtual machine uses two's-complement representation for integers and the range of two's-complement values is not symmetric, the negation of the maximum negative short results in that same maximum negative number. Despite the fact that overflow has occurred, no exception is thrown.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8543"></A>For all short values x, -x equals (&#126;x) + 1.
</P><H3 CLASS="Head2"><A NAME="pgfId-8544"></A>7.5.97	<A NAME="marker-54655"></A>sor</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8545"></A>Boolean OR short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8546"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21259"></A><I CLASS="Variable">sor</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8548"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8549"></A>sor = 85 (0x55)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8550"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8551"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8552"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8553"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. A short result is calculated by taking the bitwise inclusive OR of value1 and value2. The result is pushed onto the operand stack.
</P><H3 CLASS="Head2"><A NAME="pgfId-8554"></A>7.5.98	<A NAME="marker-54656"></A>srem</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8555"></A>Remainder short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8556"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21262"></A><I CLASS="Variable">srem</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8558"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8559"></A>srem = 73 (0x49)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8560"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8561"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8562"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8563"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. The short result is the value of the Java expression value1 - (value1 / value2) * value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8564"></A>The result of the irem instruction is such that (a/b)*b + (a%b) is equal to a. This identity holds even in the special case that the dividend is the negative short of largest possible magnitude for its type and the divisor is -1 (the remainder is 0). It follows from this rule that the result of the remainder operation can be negative only if the dividend is negative and can be positive only if the dividend is positive. Moreover, the magnitude of the result is always less than the magnitude of the divisor.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8565"></A>Runtime Exception
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8566"></A>If the value of the divisor for a short remainder operator is 0, srem throws an ArithmeticException.
</P><H3 CLASS="Head2"><A NAME="pgfId-8567"></A>7.5.99	<A NAME="marker-54657"></A>sreturn</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8568"></A>Return short from method
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8569"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21265"></A><I CLASS="Variable">sreturn</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8571"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8572"></A>sreturn = 120 (0x78)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8573"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8574"></A>..., value -&gt;
<BR>[empty]
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8575"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8576"></A>The value must be of type short. It is popped from the operand stack of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>) and pushed onto the operand stack of the frame of the invoker. Any other values on the operand stack of the current method are discarded.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8577"></A>The virtual machine then reinstates the frame of the invoker and returns control to the invoker.
</P><H3 CLASS="Head2"><A NAME="pgfId-8578"></A>7.5.100	<A NAME="marker-54658"></A>sshl</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8579"></A>Shift left short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8580"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21268"></A><I CLASS="Variable">sshl</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8582"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8583"></A>sshl = 77 (0x4d)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8584"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8585"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8586"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8587"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. A short result is calculated by shifting value1 left by s bit positions, where s is the value of the low five bits of value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8588"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8589"></A>This is equivalent (even if overflow occurs) to multiplication by 2 to the power s. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-53175"></A>The mask value of 0x1f allows shifting beyond the range of a 16-bit short value. It is used by this instruction, however, to ensure results equal to those generated by the Java instruction ishl.
</P><H3 CLASS="Head2"><A NAME="pgfId-8590"></A>7.5.101	<A NAME="marker-54659"></A>sshr</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8591"></A>Arithmetic shift right short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8592"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21271"></A><I CLASS="Variable">sshr</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8594"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8595"></A>sshr = 79 (0x4f)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8596"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8597"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8598"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8599"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. A short result is calculated by shifting value1 right by s bit positions, with sign extension, where s is the value of the low five bits of value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8600"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8601"></A>The resulting value is &Icirc;(value1) / 2s&#176;, where s is value2 &amp; 0x1f. For nonnegative value1, this is equivalent (even if overflow occurs) to truncating short division by 2 to the power s. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54668"></A>The mask value of 0x1f allows shifting beyond the range of a 16-bit short value. It is used by this instruction, however, to ensure results equal to those generated by the Java instruction ishr.
</P><H3 CLASS="Head2"><A NAME="pgfId-54669"></A>7.5.102	<A NAME="marker-54673"></A>sspush</H3>
<P CLASS="Paragraph"><A NAME="pgfId-54670"></A>Push short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8604"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21278"></A><I CLASS="Variable">sspush</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21280"></A><I CLASS="Variable">byte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21282"></A><I CLASS="Variable">byte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8608"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8609"></A>sspush = 17 (0x11)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8610"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8611"></A>... -&gt;
<BR>..., value
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8612"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8613"></A>The immediate unsigned byte1 and byte2 values are assembled into a signed short where the value of the short is (byte1 &lt;&lt; 8) | byte2. The resulting value is pushed onto the operand stack.
</P><H3 CLASS="Head2"><A NAME="pgfId-8614"></A>7.5.103	s<A NAME="marker-54674"></A>store</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8615"></A>Store short into local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8616"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21285"></A><I CLASS="Variable">sstore</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21287"></A><I CLASS="Variable">index</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8619"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8620"></A>sstore = 41 (0x29)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8621"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8622"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8623"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8624"></A>The index is an unsigned byte that must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The value on top of the operand stack must be of type short. It is popped from the operand stack, and the value of the local variable at index is set to value.
</P><H3 CLASS="Head2"><A NAME="pgfId-8625"></A>7.5.104	<A NAME="marker-54675"></A>sstore_&lt;n&gt;</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8626"></A>Store short into local variable
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8627"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21290"></A><I CLASS="Variable">sstore_&lt;n&gt;</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8629"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8630"></A>sstore_0 = 47 (0x2f)
<BR>sstore_1 = 48 (0x30)
<BR>sstore_2 = 49 (0x31)
<BR>sstore_3 = 50 (0x32)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8631"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8632"></A>..., value -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8633"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8634"></A>The &lt;n&gt; must be a valid index into the local variables of the current frame (<A HREF="JCVM03structVM.html#13656" CLASS="XRef">Section 3.5, Frames</A>). The value on top of the operand stack must be of type short. It is popped from the operand stack, and the value of the local variable at &lt;n&gt; is set to value.
</P><H3 CLASS="Head2"><A NAME="pgfId-8635"></A>7.5.105	<A NAME="marker-54676"></A>ssub</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8636"></A>Subtract short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8637"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21293"></A><I CLASS="Variable">ssub</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8639"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8640"></A>ssub = 67 (0x43)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8641"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8642"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8643"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8644"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. The short result is value1 - value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8645"></A>For short subtraction, a - b produces the same result as a + (-b). For short values, subtraction from zeros is the same as negation.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8646"></A>Despite the fact that overflow or underflow may occur, in which case the result may have a different sign than the true mathematical result, execution of a ssub instruction never throws a runtime exception.
</P><H3 CLASS="Head2"><A NAME="pgfId-8647"></A>7.5.106	<A NAME="marker-54677"></A>stableswitch</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8648"></A>Access jump table by short index and jump
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8649"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21296"></A><I CLASS="Variable">stableswitch</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21298"></A><I CLASS="Variable">defaultbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21300"></A><I CLASS="Variable">defaultbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21302"></A><I CLASS="Variable">lowbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21304"></A><I CLASS="Variable">lowbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21306"></A><I CLASS="Variable">highbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21308"></A><I CLASS="Variable">highbyte2</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21310"></A><I CLASS="Variable">jump offsets</I>...
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8658"></A>Offset Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21313"></A><I CLASS="Variable">offsetbyte1</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21315"></A><I CLASS="Variable">offsetbyte2</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8661"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8662"></A>stableswitch = 115 (0x73)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8663"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8664"></A>..., index -&gt;
<BR>...
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8665"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8666"></A>A stableswitch instruction is a variable-length instruction. Immediately after the stableswitch opcode follow a signed 16-bit value default, a signed 16-bit value low, a signed 16-bit value high, and then high - low + 1 further signed 16-bit offsets. The value low must be less than or equal to high. The high - low + 1 signed 16-bit offsets are treated as a 0-based jump table. Each of the signed 16-bit values is constructed from two unsigned bytes as (byte1 &lt;&lt; 8) | byte2.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8667"></A>The index must be of type short and is popped from the stack. If index is less than low or index is greater than high, than a target address is calculated by adding default to the address of the opcode of this stableswitch instruction. Otherwise, the offset at position index - low of the jump table is extracted. The target address is calculated by adding that offset to the address of the opcode of this stableswitch instruction. Execution then continues at the target address.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8668"></A>The target addresses that can be calculated from each jump table offset, as well as the one calculated from default, must be the address of an opcode of an instruction within the method that contains this stableswitch instruction.
</P><H3 CLASS="Head2"><A NAME="pgfId-8669"></A>7.5.107	<A NAME="marker-54678"></A>sushr</H3>
<P CLASS="Paragraph"><A NAME="pgfId-8670"></A>Logical shift right short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8671"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21318"></A><I CLASS="Variable">sushr</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8673"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8674"></A>sushr = 81 (0x51)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8675"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8676"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8677"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8678"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. A short result is calculated by sign-extending value1 to 32 bits<A NAME="fnote13"></A><A HREF="#pgfId-53202"  CLASS="footnote"><SUP>[13]</SUP></A> and shifting the result right by s bit positions, with zero extension, where s is the value of the low five bits of value2. The resulting value is then truncated to a 16-bit result. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8679"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8680"></A>If value1 is positive and s is value2 &amp; 0x1f, the result is the same as that of value1 &gt;&gt; s; if value1 is negative, the result is equal to the value of the expression (value1 &gt;&gt; s) + (2 &lt;&lt; &#126;s). The addition of the (2 &lt;&lt; &#126;s) term cancels out the propagated sign bit. The shift distance actually used is always in the range 0 to 31, inclusive, as if value2 were subjected to a bitwise logical AND with the mask value 0x1f.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54683"></A>The mask value of 0x1f allows shifting beyond the range of a 16-bit short value. It is used by this instruction, however, to ensure results equal to those generated by the Java instruction iushr.
</P><H3 CLASS="Head2"><A NAME="pgfId-54684"></A>7.5.108	s<A NAME="marker-54688"></A>wap_x</H3>
<P CLASS="Paragraph"><A NAME="pgfId-54685"></A>Swap top two operand stack words
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8683"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21321"></A><I CLASS="Variable">swap_x</I>
</P>
</TD>
</TR>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21323"></A><I CLASS="Variable">mn</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8686"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8687"></A>swap_x = 64 (0x40)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8688"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8689"></A>..., wordM+N, ..., wordM+1, wordM, ..., word1 -&gt;
<BR>..., wordM, ..., word1, wordM+N, ..., wordM+1
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8690"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8691"></A>The unsigned byte mn is used to construct two parameter values. The high nibble, (mn &amp; 0xf0) &gt;&gt; 4, is used as the value m. The low nibble, (mn &amp; 0xf), is used as the value n. Permissible values for both m and n are 1 and 2.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8692"></A>The top m words on the operand stack are swapped with the n words immediately below.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8693"></A>The swap_x instruction must not be used unless the ranges of words 1 through m and words m+1 through n each contain either a 16-bit data type, two 16-bit data types, a 32-bit data type, a 16-bit data type and a 32-bit data type (in either order), or two 32-bit data types.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8694"></A>Notes
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8695"></A>Except for restrictions preserving the integrity of 32-bit data types, the swap_x instruction operates on untyped words, ignoring the types of data they contain.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-54693"></A>If a virtual machine does not support the int data type, the only permissible value for both m and n is 1.
</P><H3 CLASS="Head2"><A NAME="pgfId-54694"></A>7.5.109	<A NAME="marker-54698"></A>sxor</H3>
<P CLASS="Paragraph"><A NAME="pgfId-54695"></A>Boolean XOR short
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8699"></A>Format
</P>
<BR>
<TABLE CLASS="Titled" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 BORDER="1" DIR="LTR"><CAPTION></CAPTION>
<TBODY>
<TR>
<TD SCOPE="ROW" ROWSPAN="1" COLSPAN="1">
<P CLASS="TableText"><A NAME="pgfId-21326"></A><I CLASS="Variable">sxor</I>
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-8701"></A>Forms
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8702"></A>sxor = 87 (0x57)
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8703"></A>Stack
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8704"></A>..., value1, value2 -&gt;
<BR>..., result
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8705"></A>Description
</P>
<P CLASS="Paragraph"><A NAME="pgfId-8706"></A>Both value1 and value2 must be of type short. The values are popped from the operand stack. A short result is calculated by taking the bitwise exclusive OR of value1 and value2. The result is pushed onto the operand stack.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-5890"></A>&nbsp;
</P>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">1</SPAN><B><A HREF="#fnote1"> (Footnote) </A></B><A NAME="pgfId-53399"></A></A>When both <I CLASS="Variable">S</I> and <I CLASS="Variable">T</I> are arrays of reference types, this algorithm is applied recursively using the types of the arrays, namely <I CLASS="Variable">SC</I> and <I CLASS="Variable">TC</I>. In the recursive call, <I CLASS="Variable">S</I>, which was <I CLASS="Variable">SC</I> in the original call, may be an interface type. This rule can only be reached in this manner. Similarly, in the recursive call,<I CLASS="Variable">T</I>, which was <I CLASS="Variable">TC</I> in the original call, may be an interface type. </SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">2</SPAN><B><A HREF="#fnote2"> (Footnote) </A></B><A NAME="pgfId-53438"></A></A>This version of the Java Card virtual machine does not support multi-dimensional arrays. Therefore, neither <I CLASS="Variable">SC</I> or <I CLASS="Variable">TC</I> can be an array type.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">3</SPAN><B><A HREF="#fnote3"> (Footnote) </A></B><A NAME="pgfId-53478"></A></A>When both <I CLASS="Variable">S</I> and <I CLASS="Variable">T</I> are arrays of reference types, this algorithm is applied recursively using the types of the arrays, namely <I CLASS="Variable">SC</I> and <I CLASS="Variable">TC</I>. In the recursive call, <I CLASS="Variable">S</I>, which was <I CLASS="Variable">SC</I> in the original call, may be an interface type. This rule can only be reached in this manner. Similarly, in the recursive call,<I CLASS="Variable">T</I>, which was <I CLASS="Variable">TC</I> in the original call, may be an interface type. </SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">4</SPAN><B><A HREF="#fnote4"> (Footnote) </A></B><A NAME="pgfId-53447"></A></A>This version of the Java Card virtual machine specification does not support multi-dimensional arrays. Therefore, neither <I CLASS="Variable">SC</I> or <I CLASS="Variable">TC</I> can be an array type.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">5</SPAN><B><A HREF="#fnote5"> (Footnote) </A></B><A NAME="pgfId-53110"></A></A>The offset may be computed by adding the field token value to the size of an instance of the immediate superclass. However, this method is not required by this specification. A Java Card virtual machine may define any mapping from token value to offset into an instance.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">6</SPAN><B><A HREF="#fnote6"> (Footnote) </A></B><A NAME="pgfId-53123"></A></A>The offset may be computed by adding the field token value to the size of an instance of the immediate superclass. However, this method is not required by this specification. A Java Card virtual machine may define any mapping from token value to offset into an instance.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">7</SPAN><B><A HREF="#fnote7"> (Footnote) </A></B><A NAME="pgfId-53130"></A></A>The offset may be computed by adding the field token value to the size of an instance of the immediate superclass. However, this method is not required by this specification. A Java Card virtual machine may define any mapping from token value to offset into an instance.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">8</SPAN><B><A HREF="#fnote8"> (Footnote) </A></B><A NAME="pgfId-53469"></A></A>When both <I CLASS="Variable">S</I> and <I CLASS="Variable">T</I> are arrays of reference types, this algorithm is applied recursively using the types of the arrays, namely <I CLASS="Variable">SC</I> and <I CLASS="Variable">TC</I>. In the recursive call, <I CLASS="Variable">S</I>, which was <I CLASS="Variable">SC</I> in the original call, may be an interface type. This rule can only be reached in this manner. Similarly, in the recursive call,<I CLASS="Variable">T</I>, which was <I CLASS="Variable">TC</I> in the original call, may be an interface type. </SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">9</SPAN><B><A HREF="#fnote9"> (Footnote) </A></B><A NAME="pgfId-53460"></A></A>This version of the Java Card virtual machine specification does not support multi-dimensional arrays. Therefore, neither <I CLASS="Variable">SC</I> or <I CLASS="Variable">TC</I> can be an array type.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">10</SPAN><B><A HREF="#fnote10"> (Footnote) </A></B><A NAME="pgfId-53528"></A></A>The offset may be computed by adding the field token value to the size of an instance of the immediate superclass. However, this method is not required by this specification. A Java Card virtual machine may define any mapping from token value to offset into an instance.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">11</SPAN><B><A HREF="#fnote11"> (Footnote) </A></B><A NAME="pgfId-53156"></A></A>The offset may be computed by adding the field token value to the size of an instance of the immediate superclass. However, this method is not required by this specification. A Java Card virtual machine may define any mapping from token value to offset into an instance.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">12</SPAN><B><A HREF="#fnote12"> (Footnote) </A></B><A NAME="pgfId-53163"></A></A>The offset may be computed by adding the field token value to the size of an instance of the immediate superclass. However, this method is not required by this specification. A Java Card virtual machine may define any mapping from token value to offset into an instance.</SUP>
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">13</SPAN><B><A HREF="#fnote13"> (Footnote) </A></B><A NAME="pgfId-53202"></A></A>Sign extension to 32 bits ensures that the result computed by this instruction will be exactly equal to that computed by the Java iushr instruction, regardless of the input values. In a Java Card virtual machine the expression &quot;0xffff &gt;&gt;&gt; 0x01&quot; yields 0xffff, where &quot;&gt;&gt;&gt;&quot; is performed by the <KBD CLASS="Filename-Command">sushr</KBD> instruction. The same result is rendered by a Java virtual machine.</SUP>
<div class="navbar" align="center">
<br>
<br>
<table dir="LTR" summary="Navigation bar, includes the book title and navigation buttons" width=100% cellpadding="0" cellspacing="0" border="0"><colgroup span="3" width="100%"><col id="1" span="1" width="45%"><col id="2" span="1" width="25%"><col id="3" span="1" width="30%">
<tr bgcolor="#cccccc">
<td class="navbartitle" align=left rowspan="1" colspan="1" abbr="ChapTitle">&nbsp;&nbsp;Virtual Machine Specification, Java Card Platform, v2.2.2
</td>
<td class="navbartitle" align=right rowspan="1" colspan="1" abbr="PartNum">3-11-06
</td>
<td valign="top" align="right" rowspan="1" colspan="1" abbr="NavButtons"><a href="index.html"><img src="shared/toc01.gif" title="Table Of Contents" alt="Table Of Contents" width="30" height="26" border="0"></a><a href="JCVM06cap.html"><img src="shared/prev01.gif" title="Previous Chapter" alt="Previous Chapter" width="30" height="26" border="0"></a><a href="JCVM08instrTables.html"><img src="shared/next01.gif" title="Next Chapter" alt="Next Chapter" width="30" height="26" border="0"></a><a href="ix.html"><img src="shared/index01.gif" title="Book Index" alt="Book Index" width="30" height="26" border="0"></a>
</td>
</tr>
</table>
<br>
<br>
</div>
<P CLASS="copyrightlink"><a href="copyright.html">Copyright</a> &#169; 2005, Sun Microsystems, Inc.   All Rights Reserved.
</P>
</BODY>
</HTML>
