<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<HTML LANG="en">
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=ISO-8859-1">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">
<META NAME="GENERATOR" CONTENT="Adobe FrameMaker 7.0/HTML Export Filter">

<LINK REL="STYLESHEET" HREF="unx_unstr_styles.css" CHARSET="ISO-8859-1" TYPE="text/css">
<META name="DC.TITLE" content="Application Programming Notes, Java Card Platform, Version 2.2.2">
<TITLE>C H A P T E R    4 - Developing RMI Applications for  the Java Card Platform 
</TITLE>
</HEAD>
<BODY BGCOLOR="#ffffff">
<DIV>
<div class="navbar" align="center">
<table dir="LTR" summary="Navigation bar, includes the book title and navigation buttons" width=100% cellpadding="0" cellspacing="0" border="0"><colgroup span="2" width="100%"><col id="1" span="1" width="50%"><col id="2" span="1" width="50%">
<tr bgcolor="#cccccc">
<td class="navbartitle" align=left rowspan="1" colspan="1" abbr="ChapTitle">&nbsp;&nbsp;Application Programming Notes, Java Card Platform, Version 2.2.2
</td>
<td valign="top" align="right" rowspan="1" colspan="1" abbr="NavButtons"><a href="index.html"><img src="shared/toc01.gif" title="Table Of Contents" alt="Table Of Contents" width="30" height="26" border="0"></a><a href="apduio.html"><img src="shared/prev01.gif" title="Previous Chapter" alt="Previous Chapter" width="30" height="26" border="0"></a><a href="extapdu.html"><img src="shared/next01.gif" title="Next Chapter" alt="Next Chapter" width="30" height="26" border="0"></a><a href="ix.html"><img src="shared/index01.gif" title="Book Index" alt="Book Index" width="30" height="26" border="0"></a>
</td>
</tr>
</table>
<br>
<br>
</div>
</DIV>
<TABLE DIR="LTR" SUMMARY="Chapter Number" ABBR="ChapNum" WIDTH="100%" BORDER="0">
<COLGROUP SPAN="1" WIDTH="100%"><COL ID="1" SPAN="1">
<TR>
<TD ALIGN="right" CLASS="ChapNumber"><SPAN CLASS="ChapNumPrefix"><A NAME="pgfId-584649"></A>C H A P T E R    </SPAN>&nbsp;<SPAN CLASS="ChapNumNum">4</SPAN><A NAME="78349"></A>
</TD>
</TR>
</TABLE>
<TABLE DIR="LTR" SUMMARY="Chapter Title" ABBR="ChapTitle" WIDTH="100%" BORDER="0">
<COLGROUP SPAN="1" WIDTH="100%"><COL ID="1" SPAN="1" WIDTH="100%">
<TR>
<TD ALIGN="right" CLASS="ChapTitle">
<HR SIZE=7 NOSHADE><A NAME="pgfId-589681"></A><A NAME="86813"></A>Developing <A NAME="marker-593989"></A>RMI Applications for the Java Card Platform
</TD>
</TR>
</TABLE>
<P CLASS="Paragraph"><A NAME="pgfId-592859"></A>This chapter describes how to write RMI applications for the Java Card platform. In this release, you can run and debug Java Card remote method invocation (Java Card RMI) applications in the C language Java Card RE and the Java Card platform Workstation Development Environment (Java Card WDE). 
</P><H2 CLASS="Head1"><A NAME="pgfId-589682"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>Developing an <A NAME="marker-593990"></A>RMI Applet for the Java Card Platform</H2>
<P CLASS="Paragraph"><A NAME="pgfId-592970"></A>Following are the main steps for developing an RMI applet for the Java Card platform:
</P>
<P CLASS="Step1"><A NAME="pgfId-592971"></A>	1.	Define remote interfaces
</P>
<P CLASS="Step1-"><A NAME="pgfId-592972"></A>	2.	Develop classes implementing the remote interfaces
</P>
<P CLASS="Step1-"><A NAME="pgfId-604726"></A>	3.	Develop the <KBD CLASS="Filename-Command">main</KBD> class for the applet
</P>
<P CLASS="Paragraph"><A NAME="pgfId-592974"></A>For a simple applet, the main class of the applet can also be the class implementing the remote interface. 
</P><H3 CLASS="Head2"><A NAME="pgfId-592975"></A>Generating<A NAME="marker-593991"></A> Stubs</H3>
<P CLASS="Paragraph"><A NAME="pgfId-593278"></A>The Java Card RMI Client framework requires stubs only when the <KBD CLASS="Filename-Command">remote_ref_with_class</KBD> format is used for passing remote references. These stubs of remote classes of applets must be pr-generated and available on the client. When the <KBD CLASS="Filename-Command">remote_ref_with_interfaces</KBD> format is used, stubs are not necessary.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-593279"></A>In this example, Sun Microsystems' standard RMI Compiler (<KBD CLASS="Filename-Command">rmic</KBD>) is used to generate these stubs.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-592977"></A>Following is the command to run the <KBD CLASS="Filename-Command">rmic</KBD>: 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-592978"></A><KBD CLASS="Filename-Command">rmic -v1.2 -classpath </KBD><I CLASS="Variable">path</I><KBD CLASS="Filename-Command"> -d </KBD><I CLASS="Variable">output_dir</I> <I CLASS="Variable">class_name</I> 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-592979"></A>where:
</P>
<P CLASS="ParaIndent1"><A NAME="pgfId-592980"></A><I CLASS="Variable">path</I> includes the path to the remote class of your sample applet and to the file <KBD CLASS="Filename-Command">javacardframework.jar</KBD>.
</P>
<P CLASS="ParaIndent1"><A NAME="pgfId-592981"></A><I CLASS="Variable">output_dir</I> is the directory in which to place the resulting stubs
</P>
<P CLASS="ParaIndent1"><A NAME="pgfId-592982"></A><I CLASS="Variable">class_name</I> is the name of the remote class
</P>
<P CLASS="ParaIndent1"><A NAME="pgfId-592983"></A>The <KBD CLASS="Filename-Command">-v1.2</KBD> flag is required by the RMI client framework for the Java Card platform.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-605613"></A>The <KBD CLASS="Filename-Command">rmic</KBD> must be called for each remote class in your applet.
</P>
<BR>
<HR NOSHADE SIZE=1>
<TABLE CLASS="TipNote" DIR="LTR" WIDTH="100%" SUMMARY="TipNote">
<COLGROUP SPAN="1" WIDTH="100%">
<TR ALIGN="left" VALIGN="top">
<TD ROWSPAN="1" COLSPAN="1" ABBR="TipNoteText">
<P CLASS="TipNote"><B CLASS="TipNote">Note - </B><A NAME="pgfId-605885"></A>You need to generate stubs only for remote classes that list a remote interface in their <KBD CLASS="Filename-Command">implements</KBD> clause.
</P>
</TD>
</TR>
</TABLE>
<HR NOSHADE SIZE=1>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-592985"></A>The file <KBD CLASS="Filename-Command">javacardframework.jar</KBD> is provided in version 2.2.2 of the Java Card development kit. This JAR file contains compiled implementations of packages <KBD CLASS="Filename-Command">javacard.framework</KBD>, <KBD CLASS="Filename-Command">javacard.framework.service</KBD>, and <KBD CLASS="Filename-Command">javacard.security</KBD>. Classes in these packages might be referenced by Java Card RMI applets and thus might be needed by the <KBD CLASS="Filename-Command">rmic</KBD> to generate stubs.
</P><H3 CLASS="Head2"><A NAME="pgfId-597085"></A><A NAME="marker-603166"></A>Running a Java Card RMI Applet</H3>
<P CLASS="Paragraph"><A NAME="pgfId-597086"></A>The server part (the Java Card RMI-enabled applet) can be run on both the C-language Java Card RE and Java Card WDE.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-597092"></A>To run the applet on the C-language Java Card RE, the standard procedures apply: the applet must be installed first, using the installer applet. After the applet is installed, the EEPROM state can be saved and used to run the C-language Java Card RE against the Java Card RMI client. 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-597096"></A>The simplest way to run a Java Card RMI-enabled applet on the Java Card WDE is to add it to the WDE configuration file on the first line. This uses the fact that the Java Card WDE automatically installs the first applet on &quot;power up.&quot; The Java Card WDE is a very convenient environment to debug Java Card RMI applets. Of course, all of the standard limitations (such as absence of firewall support) apply.
</P><H3 CLASS="Head2"><A NAME="pgfId-592986"></A>Running the <A NAME="marker-593992"></A>Java Card RMI Client Program</H3>
<P CLASS="Paragraph"><A NAME="pgfId-609305"></A>The client program can be developed and compiled using <KBD CLASS="Filename-Command">javac</KBD> or your favorite IDE. To compile the client, the remote interfaces for your applet must be present in your <KBD CLASS="Filename-Command">classpath</KBD>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-609306"></A>Running the client program has the following requirements.
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-606008"></A>The client framework file <KBD CLASS="Filename-Command">jcrmiclientframework.jar</KBD> is present in the <KBD CLASS="Filename-Command">classpath</KBD>. This file contains all the client framework and necessary classes from the card framework.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-606013"></A>The file <KBD CLASS="Filename-Command">jccclient.properties</KBD> is present in one of the directories specified in the <KBD CLASS="Filename-Command">classpath</KBD>.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-606017"></A>The remote interfaces and stubs for your applet are present in the <KBD CLASS="Filename-Command">classpath</KBD>. For a sample command line to run a client program, refer to the file <KBD CLASS="Filename-Command">rmidemo</KBD> or <KBD CLASS="Filename-Command">rmidemo.bat</KBD> in this directory.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-606021"></A>The <KBD CLASS="Filename-Command">jccclient.properties</KBD> file supplied in the <KBD CLASS="Filename-Command">samples/src/demo</KBD> directory. This file specifies parameters for <KBD CLASS="Filename-Command">com.sun.javacard.clientlib.APDUIOCardAccessor</KBD>. To be accessible at runtime, this file must be located in one of the directories listed in the <KBD CLASS="Filename-Command">classpath</KBD>. This parameter connection specified in the file can be configured to be TCP, serial or PC/SC (unsupported). The protocol being used can be T0 or T1.
</LI>
<P CLASS="Linebreak">
</P>
</UL><H2 CLASS="Head1"><A NAME="pgfId-592967"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>Basic Example</H2>
<P CLASS="Paragraph"><A NAME="pgfId-570065"></A>The basic example is the Java Card platform equivalent of &quot;Hello World,&quot; which is a program that manages a counter remotely, and is able to decrement, increment, and return the value of the counter.
</P><H3 CLASS="Head2"><A NAME="pgfId-570069"></A>Main Program</H3>
<P CLASS="Paragraph"><A NAME="pgfId-570071"></A>As for any Java Card RMI program, the first step is to define the interface to be used as contract between the server (the Java Card technology-based application) and its clients (the terminal applications):
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-608245"></A>package examples.purse ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608246"></A>import java.rmi.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608247"></A>import javacard.framework.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608248"></A>public interface Purse extends Remote {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608249"></A>  public static final short MAX_AMOUNT = 400 ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608250"></A>  public static final short REQUEST_FAILED = 0x0102 ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608251"></A>  public short debit(short amount) throws RemoteException, UserException;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608252"></A>  public short credit(short amount) throws RemoteException,
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608253"></A>      UserException ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608254"></A>  public short getBalance() throws RemoteException, UserException ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608255"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-570101"></A>This is a typical Java Card RMI interface in the following ways:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-570103"></A>The interface type extends the <KBD CLASS="Filename-Command">java.rmi.Remote</KBD> interface. This interface is a tagging interface that identifies the interface as defining a remotely accessible object.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-570105"></A>Every method in the interface must be declared as throwing a <KBD CLASS="Filename-Command">RemoteException</KBD> or one of its superclasses (<KBD CLASS="Filename-Command">IOException</KBD> or <KBD CLASS="Filename-Command">Exception</KBD>). This exception is required to encapsulate all the communication problems that might occur during a remote invocation of the method. In addition, the <KBD CLASS="Filename-Command">credit</KBD>, <KBD CLASS="Filename-Command">debit</KBD>, and <KBD CLASS="Filename-Command">getBalance</KBD> methods also throw the <KBD CLASS="Filename-Command">UserException</KBD> to indicate application-specific errors.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-570107"></A>The interface can also define values for constants that might be used in the communication between the client and the server. The <KBD CLASS="Filename-Command">Purse</KBD> interface defines a constant <KBD CLASS="Filename-Command">MAX_AMOUNT</KBD> that represents the maximum allowed value for the transaction amount parameter. It also defines a reason code <KBD CLASS="Filename-Command">REQUEST_FAILED</KBD> for the <KBD CLASS="Filename-Command">UserException</KBD> qualifier.
</LI>
<P CLASS="Linebreak">
</P>
</UL><H5 CLASS="Head4"><A NAME="pgfId-592867"></A>Implement a Remote Interface</H5>
<P CLASS="Paragraph"><A NAME="pgfId-584656"></A>The next step provides an implementation for this interface. This implementation runs on a Java Card platform, and it therefore needs to use only features that are supported by a Java Card platform:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607045"></A>package examples.purse ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607046"></A>import javacard.framework.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607047"></A>import javacard.framework.service.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607048"></A>import java.rmi.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607049"></A>public class PurseImpl extends CardRemoteObject implements Purse
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607050"></A>{
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607051"></A>  private short balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607052"></A>  PurseImpl()
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607053"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607054"></A>    super() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607055"></A>    balance = 0 ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607056"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607057"></A>  public short debit(short amount) throws RemoteException, UserException
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607058"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607059"></A>    if (( amount &lt; 0 )||( amount &gt; MAX_AMOUNT ))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607060"></A>      UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607061"></A>    balance -= amount ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607062"></A>    return balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607063"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607064"></A>  public short credit(short amount) throws RemoteException, UserException
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607065"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607066"></A>    if (( amount &lt; 0 )||( balance &lt; amount ))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607067"></A>      UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607068"></A>    balance -= amount ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607069"></A>    return balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607070"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607071"></A>  public short getBalance() throws RemoteException, UserException
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607072"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607073"></A>    return balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607074"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607075"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-586967"></A>Here, the remote interface is the <KBD CLASS="Filename-Command">Purse</KBD> interface, which declares the remotely accessible methods. By implementing this interface, the class establishes a contract between itself and the compiler, by which the class promises that it will provide method bodies for all the methods declared in the interface:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-584897"></A>public class PurseImpl extends CardRemoteObject implements Purse
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-584668"></A>The class also extends the <KBD CLASS="Filename-Command">javacard.framework.service.CardRemoteObject</KBD> class. This class provides our class with basic support for remote objects, and in particular the ability to export or unexport an object.
</P><H5 CLASS="Head4"><A NAME="pgfId-570205"></A>Define the Constructor for the Remote Object</H5>
<P CLASS="Paragraph"><A NAME="pgfId-570207"></A>The constructor for a remote class provides the same functionality as the constructor of a non-remote class: it initializes the variables of each newly created instance of the class.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-570209"></A>In addition, the remote object instance will need to be exported. Exporting a remote object makes it available to accept incoming remote method requests. By extending <KBD CLASS="Filename-Command">CardRemoteObject</KBD>, a class guarantees that its instances are exported automatically upon creation on the card.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-592823"></A>If a remote object does not extend <KBD CLASS="Filename-Command">CardRemoteObject</KBD> (directly or indirectly), you must explicitly export the remote object by calling the <KBD CLASS="Filename-Command">CardRemoteObject.export</KBD> method in the constructor of your class (or in any appropriate initialization method). Of course, this class must still implement a remote interface.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-592830"></A>To review:
</P>
<P CLASS="Paragraph"><A NAME="pgfId-587011"></A>The implementation class for a remote object needs to do the following:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-570229"></A>Implement a remote interface
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-570231"></A>Export the object so that it can accept incoming remote method calls
</LI>
<P CLASS="Linebreak">
</P>
</UL><H5 CLASS="Head4"><A NAME="pgfId-570233"></A>Provide an Implementation for Each Remote Method</H5>
<P CLASS="Paragraph"><A NAME="pgfId-570235"></A>The implementation class for a remote object contains the code that implements each of the remote methods specified in the remote interface. For example, here is the implementation of the method that debits the purse:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607092"></A>public short debit(short amount) throws RemoteException, UserException
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607093"></A>  
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607094"></A>    if (( amount &lt; 0 )||( balance &lt; amount )
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607095"></A>      UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607096"></A>    balance -= amount ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607097"></A>    return balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607098"></A>  }
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-584673"></A>An operation is only allowed if the value of its parameter is compatible with the current state of the purse object. In this particular case, the application only checks that the amounts handled are positive and that the balance of the purse always remains positive.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-570259"></A>In Java Card RMI, the arguments to and return values from remote methods are restricted. The main reason for this limitation is that the Java Card platform does not support object serialization. Following are the rules for the Java Card platform:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-570262"></A>The arguments to remote methods can be of any supported integral type (such as <KBD CLASS="Filename-Command">boolean</KBD>, <KBD CLASS="Filename-Command">byte</KBD>, <KBD CLASS="Filename-Command">short</KBD> and <KBD CLASS="Filename-Command">int</KBD>), or any single-dimensional arrays of these integral types. 
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<BR>
<HR NOSHADE SIZE=1>
<TABLE CLASS="TipNote" DIR="LTR" WIDTH="100%" SUMMARY="TipNote">
<COLGROUP SPAN="1" WIDTH="100%">
<TR ALIGN="left" VALIGN="top">
<TD ROWSPAN="1" COLSPAN="1" ABBR="TipNoteText">
<P CLASS="TipNote"><B CLASS="TipNote">Note - </B><A NAME="pgfId-604851"></A>The <KBD CLASS="Filename-Command">int</KBD> type is optionally supported on the Java Card platform, so applications that use this type might not run on all platforms.
</P>
</TD>
</TR>
</TABLE>
<HR NOSHADE SIZE=1>
<BR>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-570264"></A>The return value from a remote method can be any type supported as arguments, as well as any remote interface type. The method can also return <KBD CLASS="Filename-Command">void</KBD>.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-584674"></A>On the other hand, object passing in Java Card RMI follows the normal RMI rules:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-590186"></A>By default, non-remote objects are passed by copy, which means that all data members of an object are copied, except those marked <KBD CLASS="Filename-Command">static</KBD> or <KBD CLASS="Filename-Command">transient</KBD>. In the case of the Java Card platform, this rule is trivial to apply, because the only objects concerned are arrays of integral types.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-593343"></A>Remote objects are passed by reference. In the case of the Java Card platform, remote objects can only be passed as return values. A reference to a remote object is actually a reference to a stub, which is a client-side proxy for the remote objects. Stubs are needed only when the format <KBD CLASS="Filename-Command">remote_ref_with_class</KBD> is used for passing remote references. When another format, such as <KBD CLASS="Filename-Command">remote_ref_with_interfaces</KBD>, is used, stubs are not necessary. Stubs are described in <A HREF="rmiapp.html#37535" CLASS="XRef">Generate the Stubs</A>.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<BR>
<HR NOSHADE SIZE=1>
<TABLE CLASS="TipNote" DIR="LTR" WIDTH="100%" SUMMARY="TipNote">
<COLGROUP SPAN="1" WIDTH="100%">
<TR ALIGN="left" VALIGN="top">
<TD ROWSPAN="1" COLSPAN="1" ABBR="TipNoteText">
<P CLASS="TipNote"><B CLASS="TipNote">Note - </B><A NAME="pgfId-588931"></A>Even though the semantics of the Java Card platform transient arrays are somewhat similar to transient fields in the Java programming language, different rules apply. Java Card platform contents are copied in Java Card RMI and passed by value when they are returned from a remote method.
</P>
</TD>
</TR>
</TABLE>
<HR NOSHADE SIZE=1>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-588932"></A>A class can define methods not specified in a remote interface, but they can only be invoked on-card within the Java Card VM and cannot be invoked remotely.
</P><H3 CLASS="Head2"><A NAME="pgfId-570280"></A>Building an <A NAME="marker-593994"></A>Applet</H3>
<P CLASS="Paragraph"><A NAME="pgfId-593418"></A>In version 2.2.2 of the Java Card platform (as in version 2.1), all applications must include a class that inherits from <KBD CLASS="Filename-Command">javacard.framework.Applet</KBD>, which will provide an interface with the outside world. This also applies to applications that are based on remote objects, for two main reasons:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-570284"></A>The remote objects must be instantiated and initialized, which can be done in an applet's <KBD CLASS="Filename-Command">install</KBD> method.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-570286"></A>The remote objects must communicate with the outside world, which can be done in an applet's <KBD CLASS="Filename-Command">process</KBD> method.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-594512"></A>For conversion, an applet should be assigned with an AID known on the client side, <KBD CLASS="Filename-Command">0x00;0x01:0x02:0x03:0x04:0x05:0x06:0x07:0x08</KBD>, since this AID is used in the client program.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-584675"></A>Following is the basic code for such an applet:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607131"></A>package examples.purse ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607132"></A>import javacard.framework.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607133"></A>import javacard.framework.service.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607134"></A>import java.rmi.*;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607135"></A>public class PurseApplet extends Applet
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607136"></A>{
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607137"></A>  private Dispatcher dispatcher ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607138"></A>  private PurseApplet()
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607139"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607140"></A>    // Allocates an RMI service and sets for the Java Card platform
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607141"></A>    // the initial reference
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607142"></A>    RemoteService rmi = new RMIService( new PurseImpl() ) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607143"></A>    // Allocates a dispatcher for the remote service
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607144"></A>    dispatcher = new Dispatcher((short)1) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607145"></A>    dispatcher.addService(rmi, Dispatcher.PROCESS_COMMAND) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607146"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607147"></A>  public static void install(byte[] buffer, short offset, byte length)
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607148"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607149"></A>    // Allocates and registers the applet
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607150"></A>    (new PurseApplet()).register() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607151"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607152"></A>  public void process(APDU apdu)
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607153"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607154"></A>    dispatcher.process(apdu) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607170"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607169"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV><H5 CLASS="Head4"><A NAME="pgfId-570362"></A>Preparing and Registering the Remote Object</H5>
<P CLASS="Paragraph"><A NAME="pgfId-570364"></A>The <KBD CLASS="Filename-Command">PurseApplet</KBD> constructor contains the initialization code for the remote object. First, a <KBD CLASS="Filename-Command">javacard.framework.service.RMIService</KBD> object must be allocated. This service is an object that knows how to handle all the incoming <KBD CLASS="Filename-Command">APDU</KBD> commands related to the Java Card RMI protocol. The service must be initialized to allow remote methods on an instance of the <KBD CLASS="Filename-Command">PurseImpl</KBD> class. A new instance of <KBD CLASS="Filename-Command">PurseImpl</KBD> is created, and is specified as the initial reference parameter to the <KBD CLASS="Filename-Command">RMIService</KBD> constructor as shown in the following code snippet. The initial reference is the reference that is made public by an applet to all its clients. It is used as a bootstrap for a client session, and is similar to that registered by a Java RMI server to the Java Card RMI registry.
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-588802"></A>RemoteService rmi = new RMIService( new PurseImpl() ) ;
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-584685"></A>Then, a dispatcher is created and initialized. A dispatcher is the glue among several services. In this example, the initialization is quite simple, because there is a single service to initialize:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-585009"></A>dispatcher = new Dispatcher((short)1) ;
</PRE>
<PRE CLASS="Codeline"><A NAME="pgfId-570386"></A>dispatcher.addService(rmi, Dispatcher.PROCESS_COMMAND) ;
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-584687"></A>Finally, the applet must register itself to the Java Card RE to be made selectable. This is done in the <KBD CLASS="Filename-Command">install</KBD> method, where the applet constructor is invoked and immediately registered:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-585026"></A>(new PurseApplet()).register() ;
</PRE><H5 CLASS="Head4"><A NAME="pgfId-584689"></A>Processing the Incoming Commands</H5>
<P CLASS="Paragraph"><A NAME="pgfId-570400"></A>The processing of the incoming commands is entirely delegated to the Java Card RMI service, which knows how to handle all the incoming requests. The service also implements a default behavior for the handling of any request that it does not recognize. In Java Card RMI, the following kinds of requests that can be handled:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-570402"></A>Selection request, to which the service responds by sending its initial remote reference
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-570404"></A>Method invocation request, to which the service responds by performing the actual method invocation and returning the result
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-584690"></A>To perform these actions, the service needs privileged access to some resources that are owned by the Java Card RE (in particular, privileged access is needed to perform the method invocation). The applet delegates processing to the Java Card RMI service from its process method as follows:
</P>
<P CLASS="Paragraph"><A NAME="pgfId-586000"></A><KBD CLASS="Filename-Command">dispatcher.process(apdu) ;</KBD>
</P><H3 CLASS="Head2"><A NAME="pgfId-570420"></A>Writing a <A NAME="marker-593993"></A>Client</H3>
<P CLASS="Paragraph"><A NAME="pgfId-609038"></A>The client application runs on a terminal supporting a Java Virtual Machine<A NAME="fnote1"></A><A HREF="#pgfId-609063"  CLASS="footnote"><SUP>[1]</SUP></A> environment such as Java 2 Platform, Standard Edition (J2SE<IMG SRC=shared/chars/tm.gif TITLE="trademark" ALT="trademark"> platform) or Java 2 Platform, Micro Edition (J2ME<IMG SRC=shared/chars/tm.gif TITLE="trademark" ALT="trademark"> platform).
</P>
<P CLASS="Paragraph"><A NAME="pgfId-587202"></A>The <KBD CLASS="Filename-Command">PurseClient</KBD> application interacts with the remote stub classes generated by a stub generation tool and the Java Card platform-specific information managed by the Java Card platform client-side framework located in packages <KBD CLASS="Filename-Command">com.sun.javacard.clientlib</KBD> and <KBD CLASS="Filename-Command">com.sun.javacard.rmiclientlib</KBD>. 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-588976"></A>The following example uses standard Java RMIC compiler-generated client-side stubs. The client application as well as the Java Card client-side framework rely on the APDU I/O library for managing and communicating with the card reader and the card on which the Java Card applet <KBD CLASS="Filename-Command">PurseApplet</KBD> resides. This makes the client application very portable on J2SE platforms.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-587221"></A>The following example shows a very simple <KBD CLASS="Filename-Command">PurseClient</KBD> application that is the client application of the Java Card technology-based program <KBD CLASS="Filename-Command">PurseApplet</KBD>:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607312"></A>import examples.purse.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607313"></A>import javacard.framework.UserException ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607314"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607315"></A>  public class PurseClient extends java.lang.Object {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607316"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607317"></A>public static void main(java.lang.String[] argv) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607318"></A>// arg[0] contains the debit amount
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607319"></A>short debitAmount = (short) Integer.parseInt(argv[0]) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607320"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607321"></A>        CardAccessor ca = null;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608274"></A>try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608275"></A>            // open and powerup the card
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608276"></A>            ca = new ApduIOCardAccessor();
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608277"></A>// create an RMI connector instance for the Java Card
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608278"></A>platform
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608279"></A>            JCRMIConnect jcRMI = new JCRMIConnect(ca);
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608280"></A>            
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608281"></A>byte[] appAID = new byte[] {0x01,0x02,0x03,0x04,0x05,0x06,0x07, 0x08};
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608282"></A>            // select the Java Card applet
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608283"></A>                jcRMI.selectApplet( RMI_DEMO_AID, JCRMIConnect.REF_WITH_CLASS_NAME );
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608284"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608285"></A>or
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608292"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608347"></A>jcRMI.selectApplet( RMI_DEMO_AID, JCRMIConnect.REF_WITH_INTERFACE_NAMES );
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608343"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608408"></A>// obtain the initial reference to the Purse interface
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608409"></A>Purse myPurse = (Purse) jcRMI.getInitialReference() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608410"></A>// debit the requested amount
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608411"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608412"></A>try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608413"></A>short balance = myPurse.debit ( debitAmount ) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608414"></A>}catch ( UserException jce ) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608440"></A>short reasonCode = jce.getReason() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608441"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608272"></A>&nbsp;
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-608445"></A>// process UserException reason information
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608446"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608447"></A>// display the balance to user
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608448"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608449"></A>}catch (Exception e) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608450"></A>e.printStackTrace() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608451"></A>} finally {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608452"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608453"></A>try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608454"></A>if(ca!=null){
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608455"></A>                    ca.closeCard();
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608456"></A>                }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608457"></A>}catch (Exception e) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608458"></A>e.printStackTrace() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608459"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608460"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608461"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607270"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV><H5 CLASS="Head4"><A NAME="pgfId-570422"></A><A NAME="marker-603168"></A>Initializing and Shutting Down the Card Connection</H5>
<P CLASS="Paragraph"><A NAME="pgfId-606395"></A>The client application must open the connection to the card and close it at the end.
</P>
<BR>
<HR NOSHADE SIZE=1>
<TABLE CLASS="TipNote" DIR="LTR" WIDTH="100%" SUMMARY="TipNote">
<COLGROUP SPAN="1" WIDTH="100%">
<TR ALIGN="left" VALIGN="top">
<TD ROWSPAN="1" COLSPAN="1" ABBR="TipNoteText">
<P CLASS="TipNote"><B CLASS="TipNote">Note - </B><A NAME="pgfId-609072"></A>ApduIOCardAccessor takes its settings from the file <KBD CLASS="Filename-Command">jcclient.properties</KBD>. When one of the RMI related demos runs, its script modifies the CLASSPATH to include this file, which is located at <KBD CLASS="Filename-Command">java_card_kit-2_2_2/samples/src_client</KBD> in the binary release bundle for Solaris<IMG SRC=shared/chars/tm.gif TITLE="trademark" ALT="trademark"> or Linux platforms and at <KBD CLASS="Filename-Command">java_card_kit-2_2_2&#92;samples&#92;src_client</KBD> on the Windows platform.
</P>
</TD>
</TR>
</TABLE>
<HR NOSHADE SIZE=1>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-609074"></A>The following code shows opening and closing the connection using the RMI client framework:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607467"></A>CardAccessor ca = null;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607468"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607469"></A>// The following line initializes card connection according to 
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607470"></A>// parameters listed in the jcclient.properties file:
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607471"></A>ca = new ApduIOCardAccessor();
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607472"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607473"></A>...
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607474"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607475"></A>// The following line powers down the card and closes the connection:
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607476"></A>ca.closeCard();
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV><H5 CLASS="Head4"><A NAME="pgfId-587508"></A><A NAME="marker-603167"></A>Creating and Using a <KBD CLASS="Filename-Command">CardAccessor</KBD> Object</H5>
<P CLASS="Paragraph"><A NAME="pgfId-587605"></A>To access the Java Card applet using remote methods, the client application must obtain an instance of the <KBD CLASS="Filename-Command">CardAccessor</KBD> interface. The <KBD CLASS="Filename-Command">ApduIO</KBD> class implements the <KBD CLASS="Filename-Command">CardAccessor</KBD> interface and is included in the framework.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-587613"></A>The <KBD CLASS="Filename-Command">CardAccessor</KBD> interface is a platform-independent and framework-independent interface that is used by the RMI framework for the Java Card platform to communicate with the card. The <KBD CLASS="Filename-Command">CardAccessor</KBD> object is then provided as a parameter during construction of the <KBD CLASS="Filename-Command">JavaCardRMIConnect</KBD> class to initiate an RMI dialogue for the Java Card platform as the following code shows:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-589088"></A>// create an RMI connection object for the Java Card platform
</PRE>
<PRE CLASS="Codeline"><A NAME="pgfId-589089"></A>JavaCardRMIConnect jcRMI = new JavaCardRMIConnect( myCS ) ; 
</PRE><H5 CLASS="Head4"><A NAME="pgfId-587628"></A>Selecting the Java Card Applet and Obtaining the Initial Reference</H5>
<P CLASS="Paragraph"><A NAME="pgfId-587642"></A>To invoke methods on the remote objects of the Java Card applet <KBD CLASS="Filename-Command">PurseApplet</KBD> on the card, it must first be selected using the AID:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607496"></A>// select the Java Card applet
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607497"></A>  byte[] appAID = new byte[] {0x01,0x02,0x03,0x04,0x05,0x06,0x07, 0x08} ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607498"></A>  jcRMI.selectApplet( appAID ) ;
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-587660"></A>Then, the client must obtain the initial reference remote object for <KBD CLASS="Filename-Command">PurseApplet</KBD>. <KBD CLASS="Filename-Command">JavaCardRMIConnect</KBD> returns an instance of a stub class corresponding to the <KBD CLASS="Filename-Command">PurseImpl</KBD> class on the card which implements the <KBD CLASS="Filename-Command">Purse</KBD> interface. The client application knows beforehand that the <KBD CLASS="Filename-Command">PurseApplet</KBD>'s initial remote reference implements the <KBD CLASS="Filename-Command">Purse</KBD> interface and therefore casts it appropriately: 
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-587650"></A>// obtain the initial reference to the Purse interface
</PRE>
<PRE CLASS="Codeline"><A NAME="pgfId-587643"></A>Purse myPurse = (Purse) jcRMI.getInitialReference() ;
</PRE><H5 CLASS="Head4"><A NAME="pgfId-587689"></A>Using Remote Objects in Remote Method Invocations</H5>
<P CLASS="Paragraph"><A NAME="pgfId-587699"></A>The client can now invoke remote methods on the initial reference object. The remote methods are declared in the <KBD CLASS="Filename-Command">Purse</KBD> interface. The following code shows the client invoking the <KBD CLASS="Filename-Command">debit</KBD> method. Note how an <KBD CLASS="Filename-Command">UserException</KBD> exception thrown by the remote method is caught by the client code in a normal Java programming language style.
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607520"></A>// debit the requested amount
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607521"></A>try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607522"></A>    short balance = myPurse.debit ( debitAmount ) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607523"></A>    }catch ( UserException jce ) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607524"></A>    short reasonCode = jce.getReason() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607525"></A>    // process on card exception reason information
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607526"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV><H5 CLASS="Head4"><A NAME="pgfId-570432"></A><A NAME="37535"></A>Generate the Stubs</H5>
<P CLASS="Paragraph"><A NAME="pgfId-587763"></A><A NAME="marker-603169"></A>The client-side scenario uses RMIC generated stubs for the remote classes. RMIC is the Java RMI stub compiler. For the client application <KBD CLASS="Filename-Command">PurseClient</KBD> to execute correctly on the terminal, it needs these remote stub classes and the remote interface class files it uses to be accessible in its classpath.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-587775"></A>The stub class <KBD CLASS="Filename-Command">PurseImpl_Stub.class</KBD> for the <KBD CLASS="Filename-Command">PurseImpl</KBD> class is produced by running the standard JDK1.5 RMIC compiler. For example, when in the <KBD CLASS="Filename-Command">examples/purse</KBD> directory, enter the following commands:
</P>
<P CLASS="Paragraph"><A NAME="pgfId-593364"></A><EM CLASS="Emphasis">Solaris and Linux platforms</EM>:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-593367"></A>rmic -classpath ../..;$JC_HOME/lib/javacardframework.jar -d ../.. -v1.2 examples.purse.PurseImpl
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-593370"></A><EM CLASS="Emphasis">Microsoft Windows platform</EM>:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-593373"></A>rmic -classpath ../..;%JC_HOME%/lib/javacardframework.jar -d ../.. -v1.2 examples.purse.PurseImpl
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-587760"></A>This produces a stub class called <KBD CLASS="Filename-Command">examples.purse.PurseImpl_Stub</KBD>.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-587792"></A>Thus, for <KBD CLASS="Filename-Command">PurseClient</KBD> to run correctly on the terminal, the following files must be present in the <KBD CLASS="Filename-Command">examples/purse</KBD> directory and accessible via its classpath or from class loaders:
</P>
<UL>
<LI CLASS="Bullet1-"><A NAME="pgfId-587793"></A><KBD CLASS="Filename-Command">PurseImpl_Stub.class</KBD>
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1-"><A NAME="pgfId-587794"></A><KBD CLASS="Filename-Command">Purse.class</KBD>
</LI>
<P CLASS="Linebreak">
</P>
</UL><H3 CLASS="Head2"><A NAME="pgfId-587808"></A><A NAME="marker-593995"></A>Card Terminal Interaction</H3>
<P CLASS="Paragraph"><A NAME="pgfId-587849"></A>When a Java Card technology-enabled smart card is powered up, the card sends an ATR (Answer to Reset) to the terminal. The Card Accessor returns the value of the ATR to the client program.
</P>
<BR>
<P CLASS="FigureBox"><A NAME="pgfId-595463"></A><A NAME="pgfId-615038"></A><CAPTION CLASS="FigureCaption"><A NAME="pgfId-603087"></A>FIGURE 4-1 	 <A NAME="48826"></A>Smart Card Sends an ATR to the Terminal </CAPTION>
</P>
<P><IMG SRC="figures/rmiapp-5.jpg" ALIGN="BASELINE" ALT="This figure was described before the figure." TITLE="This figure was described before the figure.">
</P>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-588567"></A>When the <KBD CLASS="Filename-Command">PurseClient</KBD> application calls the <KBD CLASS="Filename-Command">selectApplet</KBD> method of <KBD CLASS="Filename-Command">JavaCardRMIConnect</KBD>, it sends a <KBD CLASS="Filename-Command">SELECT APDU</KBD> command to the card via the <KBD CLASS="Filename-Command">CardAccessor</KBD> object. This results in a File Control Information (FCI) APDU response from the <KBD CLASS="Filename-Command">RMIService</KBD> instance of <KBD CLASS="Filename-Command">PurseApplet</KBD> on the card in a TLV (Tag Length Value) format that includes the initial reference remote object information, which <A HREF="rmiapp.html#70573" CLASS="XRef">FIGURE 4-2</A> illustrates.
</P>
<BR>
<P CLASS="FigureBox"><A NAME="pgfId-595475"></A><A NAME="pgfId-615043"></A><CAPTION CLASS="FigureCaption"><A NAME="pgfId-603096"></A>FIGURE 4-2 	 <A NAME="70573"></A>Terminal Sends a  <KBD CLASS="Filename-Command">SELECT </KBD> Command to the Smart Card, which Returns FCI </CAPTION>
</P>
<P><IMG SRC="figures/rmiapp-6.jpg" ALIGN="BASELINE" ALT="This figure was described before the figure." TITLE="This figure was described before the figure.">
</P>
<BR>
<P CLASS="Paragraph"><A NAME="pgfId-587835"></A>Later, when the <KBD CLASS="Filename-Command">PurseClient</KBD> application calls the <KBD CLASS="Filename-Command">debit</KBD> method of the remote interface <KBD CLASS="Filename-Command">Purse</KBD>, the <KBD CLASS="Filename-Command">PurseImpl_Stub</KBD> object sends an invoke command to the card via the <KBD CLASS="Filename-Command">CardAccessor</KBD> object, identifying the remote object reference, interface, method, and parameter data for method invocation. The <KBD CLASS="Filename-Command">RMIService</KBD> instance of <KBD CLASS="Filename-Command">PurseApplet</KBD> unmarshalls this information and invokes the <KBD CLASS="Filename-Command">debit</KBD> method of the <KBD CLASS="Filename-Command">PurseImpl</KBD> instance, and returns the return value in the response <KBD CLASS="Filename-Command">APDU</KBD>, which <A HREF="rmiapp.html#52582" CLASS="XRef">FIGURE 4-3</A> illustrates.
</P>
<BR>
<P CLASS="FigureBox"><A NAME="pgfId-603111"></A><A NAME="pgfId-615048"></A><CAPTION CLASS="FigureCaption"><A NAME="pgfId-603114"></A>FIGURE 4-3 	Terminal Sends an  <KBD CLASS="Filename-Command">INVOKE </KBD> Command to the Smart Card, Which Returns a Value <A NAME="52582"></A></CAPTION>
</P>
<P><IMG SRC="figures/rmiapp-7.jpg" ALIGN="BASELINE" ALT="This figure was described before the figure." TITLE="This figure was described before the figure.">
</P>
<BR><H2 CLASS="Head1"><A NAME="pgfId-587950"></A>
<DIV>
<HR ALIGN=left SIZE=6 WIDTH=15% noshade>
</DIV>Adding<A NAME="marker-593996"></A> Security</H2>
<P CLASS="Paragraph"><A NAME="pgfId-604594"></A>This first example is extremely simple and is not realistic. In particular, it does not include any kind of security. Users are not authenticated and no transport security is provided. Of course, every smart card that implements the Java Card platform includes such security mechanisms, because they are central to Java Card technology.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-570448"></A>The following section describes how to add security support to the <KBD CLASS="Filename-Command">Purse</KBD> example.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-570454"></A>The <KBD CLASS="Filename-Command">Purse</KBD> interface in the package <KBD CLASS="Filename-Command">examples.securepurse</KBD> is similar to the <KBD CLASS="Filename-Command">Purse</KBD> interface in the previous code sample. In addition, it might include reason codes for exceptions to report security violations to the terminal. Replace it with <KBD CLASS="Filename-Command">examples.securepurse</KBD>. The interface does not include any implementation, which means that, in particular, it does not include any support for security.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-607633"></A>The applet keeps its original organization but it also includes additional code that is dedicated to the management of security.
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607744"></A>package examples.securepurse ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607745"></A>import javacard.framework.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607746"></A>import javacard.framework.service.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607747"></A>import java.rmi.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607748"></A>public class SecurePurseImpl implements Purse
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607749"></A>{
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607750"></A>  private short balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607751"></A>  private SecurityService security ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607752"></A>  SecurePurseImpl(SecurityService security)
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607753"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607754"></A>    this.security = security ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607755"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607756"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607757"></A>public short debit(short amount) throws RemoteException, UserException
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607758"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607759"></A>  if
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607760"></A>  ((!security.isCommandSecure(SecurityService.PROPERTY_INPUT_INTEGRITY))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607761"></A>  ||
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607762"></A>  (!security.isAuthenticated(SecurityService.PRINCIPAL_CARDHOLDER)))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607763"></A>    UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607764"></A>    if (( amount &lt; 0 )|| ( balance &lt; amount ))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607765"></A>      UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607766"></A>    balance -= amount ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607767"></A>    return balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607768"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607769"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607770"></A>public short credit(short amount) throws RemoteException, UserException
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607771"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607772"></A>    if
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607773"></A>    ((!security.isCommandSecure(SecurityService.PROPERTY_INPUT_INTEGRITY))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607774"></A>    ||
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607775"></A>    (!security.isAuthenticated(SecurityService.PRINCIPAL_APP_PROVIDER)))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607776"></A>      UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607777"></A>    if (( amount &lt; 0 )||( amount &gt; MAX_AMOUNT ))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607778"></A>      UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607779"></A>    balance += amount ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607780"></A>    return balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607781"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607782"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607783"></A>public short getBalance() throws RemoteException, UserException
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607784"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607785"></A>    if ((!security. isAuthenticated(SecurityService.PRINCIPAL_CARDHOLDER)) 
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607786"></A>    &amp;&amp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607787"></A>    (!security.isAuthenticated(SecurityService.PRINCIPAL_APP_PROVIDER)))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607788"></A>      UserException.throwIt(REQUEST_FAILED) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607789"></A>    return balance ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607790"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607791"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV><H5 CLASS="Head4"><A NAME="pgfId-570566"></A>Initialize a Security Service</H5>
<P CLASS="Paragraph"><A NAME="pgfId-570568"></A>In this example, basic security services (principal identification and authentication, secure communication channel) are provided by an object that implements the <KBD CLASS="Filename-Command">SecurityService</KBD> interface. Because a generic remote object must not be dependent on a particular kind of security service, it must take a reference to this object as a parameter to its constructor. This is exactly what happens here, where the reference to the object is stored in a dedicated private field:
</P>
<P CLASS="Paragraph"><A NAME="pgfId-585060"></A><KBD CLASS="Filename-Command">private SecurityService security ;</KBD>
</P>
<P CLASS="Paragraph"><A NAME="pgfId-584708"></A>The <KBD CLASS="Filename-Command">SecurityService</KBD> interface is part of the extended application development framework and offers an API that can then be used to check on the current security status.
</P><H5 CLASS="Head4"><A NAME="pgfId-570578"></A>Use the Service to Check the Current Security Status</H5>
<P CLASS="Paragraph"><A NAME="pgfId-570580"></A>In the example, this following required security behaviors for the applet are assumed:
</P>
<UL>
<LI CLASS="Bullet1"><A NAME="pgfId-570582"></A>The <KBD CLASS="Filename-Command">debit</KBD> method is authorized only if it is sent through a secure channel that ensures at least the integrity of input data, and if the cardholder is successfully authenticated.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-570584"></A>The <KBD CLASS="Filename-Command">credit</KBD> method is authorized only if it is sent through a secure channel that ensures at least the integrity of input data, and if the application issuer is successfully authenticated.
</LI>
<P CLASS="Linebreak">
</P>
<LI CLASS="Bullet1"><A NAME="pgfId-570586"></A>The <KBD CLASS="Filename-Command">getBalance</KBD> method is authorized only if the cardholder or the application issuer is successfully authenticated.
</LI>
<P CLASS="Linebreak">
</P>
</UL>
<P CLASS="Paragraph"><A NAME="pgfId-584709"></A>The <KBD CLASS="Filename-Command">SecurityService</KBD> provides methods and constants that allow the implementation to perform such checks. For instance, following is the code for the checks on the <KBD CLASS="Filename-Command">debit</KBD> method:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607649"></A>if
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607650"></A>((!security.isCommandSecure(SecurityService.PROPERTY_INPUT_INTEGRITY))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607651"></A>  ||  
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607652"></A>  (security.isAuthenticated(SecurityService.ID_CARDHOLDER)))
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607653"></A>    UserException.throwIt(REQUEST_FAILED) ;
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-584711"></A>If one of the two conditions is not satisfied, the remote object throws an exception. This exception is caught by the dispatcher and forwarded to the client.
</P><H3 CLASS="Head2"><A NAME="pgfId-593733"></A><A NAME="marker-603174"></A>Implementing a Security Service</H3>
<P CLASS="Paragraph"><A NAME="pgfId-607732"></A>The following example shows how to implement a security service.
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607847"></A>package com.sun.javacard.samples.SecureRMIDemo ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607848"></A>import javacard.framework.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607849"></A>import javacard.framework.service.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607850"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607851"></A>public class MySecurityService extends BasicService implements SecurityService {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607852"></A>// list IDs of known parties...
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607853"></A>    private static final byte[] PRINCIPAL_APP_PROVIDER_ID = {0x12, 0x34} ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607854"></A>    private static final byte[] PRINCIPAL_CARDHOLDER_ID = {0x43, 0x21} ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607855"></A>    private OwnerPIN provider_pin, cardholder_pin = null ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607856"></A>    // and the security-related session flags
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607857"></A>    ...   
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607858"></A>    public MySecurityService() {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607859"></A>        // initialize the PINs
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607860"></A>        ...
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607861"></A>    }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607862"></A>     public boolean processDataIn(APDU apdu) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607863"></A>      if(selectingApplet()) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607864"></A>           // reset all flags
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607865"></A>            ...
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607866"></A>      }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607867"></A>      else {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607868"></A>          return preprocessCommandAPDU(apdu);
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607869"></A>      }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607870"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607871"></A>  public boolean isCommandSecure(byte properties) throws ServiceException {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607872"></A>      // return the value of appropriate flag
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607873"></A>      ....
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607874"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607875"></A>  public boolean isAuthenticated(short principal) throws ServiceException {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607876"></A>      // return the value of appropriate flag
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607877"></A>      ....
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607878"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607879"></A>  private byte authenticated ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607880"></A>  private boolean preprocessCommandAPDU(APDU apdu) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607881"></A>      receiveInData(apdu) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607882"></A>      if(checkAndRemoveChecksum(apdu)) {
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607938"></A>        // set DATA_INTEGRITY flag
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607939"></A>      }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607940"></A>      else {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607941"></A>          // reset DATA_INTEGRITY flag
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607942"></A>      }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607943"></A>      return false;   // other services may also preprocess the data
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607944"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607945"></A>  private boolean checkAndRemoveChecksum(APDU apdu) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607946"></A>          // remove the checksum
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607947"></A>          // return true if checksum OK, false otherwise
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607948"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607957"></A>  public boolean processCommand(APDU apdu) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607958"></A>      if(isAuthenticate(apdu)) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607959"></A>          receiveInData(apdu) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607960"></A>          // check PIN
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607961"></A>          // set AUTHENTICATED flags
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607962"></A>          return true;     //  processing of the command is finished
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607963"></A>      }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607964"></A>      else {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607965"></A>           return false ;  // this command was addressed to another
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607966"></A>                           // service - no processing is done
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607978"></A>      }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607979"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607980"></A>  public boolean processDataOut(APDU apdu) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607981"></A>      // add checksum to outgoing data
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607982"></A>      return false;  // other services may also postprocess outgoing data
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607983"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607984"></A>  private boolean isAuthenticate(APDU command) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607985"></A>              // check values of CLA and INS bytes 
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607986"></A>  } 
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607987"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV><H3 CLASS="Head2"><A NAME="pgfId-607928"></A>Building an <A NAME="marker-593997"></A>Applet</H3>
<P CLASS="Paragraph"><A NAME="pgfId-570608"></A>The supporting applet also must undergo some significant changes, in particular regarding the initialization of the remote object:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-607675"></A>package examples.securepurse ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607676"></A>import javacard.framework.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607677"></A>import javacard.framework.service.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607678"></A>import java.rmi.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607679"></A>import com.sun.javacard.samples.SecureRMIDemo.MySecurityService ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607680"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607681"></A>public class SecurePurseApplet extends Applet
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607682"></A>{
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607683"></A>  Dispatcher dispatcher ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607684"></A>  private SecurePurseApplet()
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607685"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607686"></A>    SecurityService sec ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607687"></A>    // First get a security service
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607688"></A>    sec = new MySecurityService() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607689"></A>    // Allocates an RMI service for the Java Card platform and 
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607690"></A>    // sets the initial reference
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607691"></A>    RemoteService rmi = new RMIService( new SecurePurseImpl(sec) ) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607692"></A>    // Allocates and initializes a dispatcher for the remote object
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607693"></A>    dispatcher = new Dispatcher((short)2) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607694"></A>    dispatcher.addService(rmi, Dispatcher.PROCESS_COMMAND) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607695"></A>    dispatcher.addService(sec, Dispatcher.PROCESS_INPUT_DATA) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607696"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607697"></A>  public static void install(byte[] buffer, short offset, byte length)
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607698"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607699"></A>    // Allocates and registers the applet
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607700"></A>    (new SecurePurseApplet()).register() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607701"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607702"></A>  public void process(APDU apdu)
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607703"></A>  {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607704"></A>    dispatcher.process(apdu) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607705"></A>  }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-607706"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-584722"></A>The security service that is used by the remote object must be initialized at some point. Here, this is done in the constructor for the <KBD CLASS="Filename-Command">SecurePurseApplet</KBD>:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-585096"></A><KBD CLASS="Filename-Command">sec = new MySecurityService() ;</KBD>
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-584724"></A>The initialization then goes on with the initialization of the Java Card RMI service. The only new thing here is that the remote object being allocated and set as the initial reference is now a <KBD CLASS="Filename-Command">SecurePurseImpl</KBD>:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-584725"></A><KBD CLASS="Filename-Command">RemoteService rmi = new RMIService( new SecurePurseImpl(sec) );</KBD>
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-584726"></A>Next, the dispatcher must be initialized. Here, it must dispatch simple Java Card RMI requests and security-related requests (such as <KBD CLASS="Filename-Command">EXTERNAL AUTHENTICATE</KBD>). In fact, the security service handles these requests directly. First, allocate a dispatcher and inform it that it will delegate commands to two different services:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-584727"></A><KBD CLASS="Filename-Command">dispatcher = new Dispatcher((short)2);</KBD>
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-584728"></A>Then, register services with the dispatcher. The security service is registered as a service that performs preprocessing operations on incoming commands, and the Java Card RMI service is registered as a service that processes the command requested:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-584729"></A><KBD CLASS="Filename-Command">dispatcher.addService(rmi, Dispatcher.PROCESS_COMMAND) ;</KBD>
</PRE>
<PRE CLASS="Codeline"><A NAME="pgfId-570728"></A><KBD CLASS="Filename-Command">dispatcher.addService(sec, Dispatcher.PROCESS_INPUT_DATA) ;</KBD>
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-584730"></A>The rest of the class (<KBD CLASS="Filename-Command">install</KBD> and <KBD CLASS="Filename-Command">process</KBD> methods) remain unchanged.
</P><H3 CLASS="Head2"><A NAME="pgfId-584731"></A>Writing a <A NAME="marker-593998"></A>Client</H3>
<P CLASS="Paragraph"><A NAME="pgfId-588002"></A>The driver client application itself only changes minimally to account for the authentication and integrity needs of <KBD CLASS="Filename-Command">SecurePurseApplet</KBD>. It must also interact with the user for identification. Hence, a subclass of <KBD CLASS="Filename-Command">ApduIO_Card_Accessor</KBD> must be developed to provide these additional interactions and the transport filtering required.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-588014"></A>Following is the new <KBD CLASS="Filename-Command">SecurePurseClient</KBD> application:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-608033"></A>import examples.purse.* ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608034"></A>import javacard.framework.UserException ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608035"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608036"></A>public class PurseClient extends java.lang.Object {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608037"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608038"></A>public static void main(java.lang.String[] argv) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608039"></A>// arg[0] contains the debit amount
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608040"></A>short debitAmount = (short) Integer.parseInt(argv[0]) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608041"></A>        CustomCardAccessor cca = null;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608042"></A>try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608043"></A>            // open and powerup the card - using CustomCardAccessor
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608044"></A>            cca = new CustomCardAccessor(new ApduIOCardAccessor());
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608045"></A>// create an RMI connector instance for the Java Card
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608046"></A>platform
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608047"></A>            JCRMIConnect jcRMI = new JCRMIConnect(ca);
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608048"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608049"></A>byte[] appAID = new byte[] {0x01,0x02,0x03,0x04,0x05,0x06,0x07, 0x08};
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608089"></A>// select the Java Card applet
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608090"></A>                jcRMI.selectApplet( RMI_DEMO_AID, JCRMIConnect.REF_WITH_CLASS_NAME );
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608091"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608092"></A>or
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608093"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608114"></A>jcRMI.selectApplet( RMI_DEMO_AID, JCRMIConnect.REF_WITH_INTERFACE_NAMES );
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608017"></A>&nbsp;
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-608133"></A>// give your PIN
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608134"></A>            if (! cca.authenticateUser( PRINCIPAL_CARDHOLDER_ID )){
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608135"></A>                throw new RemoteException(msg.getString(&quot;msg04&quot;));
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608136"></A>            }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608137"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608138"></A>// obtain the initial reference to the Purse interface
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608139"></A>Purse myPurse = (Purse) jcRMI.getInitialReference() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608140"></A>// debit the requested amount
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608141"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608142"></A>try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608143"></A>short balance = myPurse.debit ( debitAmount ) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608144"></A>}catch ( UserException jce ) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608145"></A>short reasonCode = jce.getReason() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608146"></A>// process UserException reason information
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608147"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608148"></A>// display the balance to user
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608149"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608150"></A>}catch (Exception e) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608151"></A>e.printStackTrace() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608152"></A>} finally {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608153"></A>try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608154"></A>                if(ca!=null){
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608155"></A>                    cca.closeCard();
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608156"></A>                }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608157"></A>}catch (Exception e) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608158"></A>e.printStackTrace() ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608159"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608160"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608161"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608162"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608128"></A>&nbsp;
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-606664"></A>Note that the <KBD CLASS="Filename-Command">CustomCardAccessor</KBD> instance is now obtained instead of <KBD CLASS="Filename-Command">ApduIOCardAccessor</KBD>:
</P>
<PRE CLASS="Codeline"><A NAME="pgfId-606667"></A>cca = new CustomCardAccessor(new ApduIOCardAccessor());
</PRE>
<P CLASS="Paragraph"><A NAME="pgfId-606662"></A>An extra step to authenticate with the <KBD CLASS="Filename-Command">SecurePurseApplet</KBD> after <KBD CLASS="Filename-Command">selectApplet</KBD> is added. This invokes a new method in <KBD CLASS="Filename-Command">CustomCardAccessor</KBD> to interact with the card using the user's credentials:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-608320"></A>if (! cca.authenticateUser( PRINCIPAL_CARDHOLDER_ID )) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608321"></A>    // handle error
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608322"></A>}
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-588282"></A>The rest of <KBD CLASS="Filename-Command">SecurePurseClient</KBD> is the same as <KBD CLASS="Filename-Command">PurseClient</KBD>.
</P><H5 CLASS="Head4"><A NAME="pgfId-588292"></A>Writing a CustomCardAccessor Class</H5>
<P CLASS="Paragraph"><A NAME="pgfId-588296"></A>The <KBD CLASS="Filename-Command">SecurePurseClient</KBD> application uses a subclass of <KBD CLASS="Filename-Command">CardAccessor</KBD> called <KBD CLASS="Filename-Command">CustomCardAccessor</KBD> to perform user authentication functions and to sign every message sent thereafter for integrity purposes:
</P>
<DIV CLASS="Code">
<BR>
<TABLE CLASS="Code" BORDER=1 BORDERCOLORLIGHT="#FFFFFF" BORDERCOLORDARK="#000000" CELLPADDING=5 CELLSPACING=0 DIR="LTR">
<TBODY>
<TR>
<TD SCOPE="ROW">
<P CLASS="TableTextCode"><A NAME="pgfId-608176"></A>package examples.securepurseclient;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608177"></A>&nbsp;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608178"></A>public class CustomCardAccessor extends 
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608179"></A>              ApduIOCardAccessor {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608180"></A>      /** Creates new CustomCardAccessor */
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608181"></A>    public CustomCardAccessor() {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608182"></A>    }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608183"></A>  public byte[] exchangeAPDU( byte[] sendData )
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608184"></A>throws java.io.IOException {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608185"></A>        
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608186"></A>        byte[] macSignature = null ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608187"></A>        byte[] dataWithMAC = new byte[ sendData.length + 4 ] ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608188"></A>        
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608189"></A>        // sign the sendData data using session key        
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608190"></A>        // sign the data in commandBuffer using the user's session key
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608191"></A>        
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608192"></A>        // add generated MAC signature to data in buffer before sending
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608193"></A>        
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608194"></A>        return super.exchangeAPDU( dataWithMAC ) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608195"></A>    }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608196"></A>    boolean authenticateUser( short userKey ) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608197"></A>        byte[] externalAuthCommand = null ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608198"></A>        
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608199"></A>        // build and send the appropriate commands to the
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608200"></A>        // applet to authenticate the user using the user Key
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608201"></A>        // and additional info provided
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608202"></A>        try {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608203"></A>          byte[] response = super.exchangeAPDU ( externalAuthCommand ) ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608204"></A>            // ...
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608205"></A>         }catch (Exception e) {
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608206"></A>            // analyze
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608207"></A>            return false ;
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608208"></A>        }   
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608209"></A>        // Then compute the session key for later use
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608210"></A>        return true; //successful authentication
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608211"></A>    }
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608212"></A>}
</P>
<P CLASS="TableTextCode"><A NAME="pgfId-608172"></A>&nbsp;
</P>
</TD>
</TR>
</TBODY>
</TABLE>
<BR>
</DIV>
<P CLASS="Paragraph"><A NAME="pgfId-588466"></A>The <KBD CLASS="Filename-Command">CustomCardAccessor</KBD> class introduces the <KBD CLASS="Filename-Command">authenticateUser</KBD> method to send <KBD CLASS="Filename-Command">APDU</KBD> commands to the <KBD CLASS="Filename-Command">SecurePurseApplet</KBD> on the card to authenticate the user described by the <KBD CLASS="Filename-Command">userKey</KBD> parameter and other parameters and to compute a transport key. It invokes <KBD CLASS="Filename-Command">super.sendCommandAPDU</KBD> method to send the command without modification.
</P>
<P CLASS="Paragraph"><A NAME="pgfId-588467"></A>This <KBD CLASS="Filename-Command">CustomCardAccessor</KBD> class also reimplements the <KBD CLASS="Filename-Command">exchangeAPDU</KBD> method declared in a superclass <KBD CLASS="Filename-Command">CardAccessor</KBD> to sign each message before it is sent out by <KBD CLASS="Filename-Command">super.exchangeAPDU</KBD>. 
</P>
<P CLASS="Paragraph"><A NAME="pgfId-589812"></A>&nbsp;
</P>
<HR>
<DIV CLASS="footnotes">
<DIV CLASS="footnote"><SUP CLASS="Footnote"><SPAN CLASS="footnoteNumber">1</SPAN><B><A HREF="#fnote1"> (Footnote) </A></B><A NAME="pgfId-609063"></A></A> The terms &quot;Java Virtual Machine&quot; and &quot;JVM&quot; mean a Virtual Machine for the Java platform.</SUP>
<div class="navbar" align="center">
<br>
<br>
<table dir="LTR" summary="Navigation bar, includes the book title and navigation buttons" width=100% cellpadding="0" cellspacing="0" border="0"><colgroup span="3" width="100%"><col id="1" span="1" width="45%"><col id="2" span="1" width="25%"><col id="3" span="1" width="30%">
<tr bgcolor="#cccccc">
<td class="navbartitle" align=left rowspan="1" colspan="1" abbr="ChapTitle">&nbsp;&nbsp;Application Programming Notes, Java Card Platform, Version 2.2.2
</td>
<td class="navbartitle" align=right rowspan="1" colspan="1" abbr="PartNum">3-11-06
</td>
<td valign="top" align="right" rowspan="1" colspan="1" abbr="NavButtons"><a href="index.html"><img src="shared/toc01.gif" title="Table Of Contents" alt="Table Of Contents" width="30" height="26" border="0"></a><a href="apduio.html"><img src="shared/prev01.gif" title="Previous Chapter" alt="Previous Chapter" width="30" height="26" border="0"></a><a href="extapdu.html"><img src="shared/next01.gif" title="Next Chapter" alt="Next Chapter" width="30" height="26" border="0"></a><a href="ix.html"><img src="shared/index01.gif" title="Book Index" alt="Book Index" width="30" height="26" border="0"></a>
</td>
</tr>
</table>
<br>
<br>
</div>
<P CLASS="copyrightlink"><A HREF="copyright.html">Copyright</a> &#169; 2005, Sun Microsystems, Inc.   All Rights Reserved.</P>
</BODY>
</HTML>
